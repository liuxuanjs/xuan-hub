
## 概述

前端模块化是现代 JavaScript 开发的基础，它解决了代码组织、依赖管理和命名冲突等问题。本文将详细介绍几种主流的模块化规范。

## 1. CommonJS

**适用场景**：Node.js 服务端开发

CommonJS 是最早的 JavaScript 模块化规范，主要用于 Node.js 环境。

### 基本语法
```js
// math.js - 导出模块
const add = (a, b) => a + b;
const subtract = (a, b) => a - b;

module.exports = { add, subtract };
// 或者
exports.add = add;
exports.subtract = subtract;

// app.js - 导入模块
const { add, subtract } = require('./math');
console.log(add(1, 2)); // 3
```

### 优缺点

**优点**：
- 语法简单，易于理解
- 同步加载，适合服务端
- Node.js 原生支持

**缺点**：
- 同步加载不适合浏览器环境
- 不支持静态分析
- 运行时确定依赖关系

## 2. AMD (Asynchronous Module Definition)

**适用场景**：浏览器端异步加载

AMD 专门为浏览器环境设计，支持异步加载模块。

### 基本语法
```js
// math.js - 定义模块
define([], function() {
  return {
    add: (a, b) => a + b,
    subtract: (a, b) => a - b
  };
});

// app.js - 使用模块
require(['./math'], function(math) {
  console.log(math.add(1, 2)); // 3
});
```

### 优缺点

**优点**：
- 异步加载，不阻塞页面渲染
- 适合浏览器环境
- 依赖关系清晰

**缺点**：
- 语法相对复杂
- 需要额外的加载器（如 RequireJS）
- 开发体验不够友好

## 3. CMD (Common Module Definition)

**适用场景**：浏览器端，依赖就近原则

CMD 由国内的 SeaJS 提出，强调"依赖就近，延迟执行"。

### 基本语法
```js
// math.js - 定义模块
define(function(require, exports, module) {
  exports.add = (a, b) => a + b;
  exports.subtract = (a, b) => a - b;
});

// app.js - 使用模块
define(function(require, exports, module) {
  const math = require('./math'); // 依赖就近
  console.log(math.add(1, 2));
});
```

### 优缺点

**优点**：
- 依赖就近，代码更清晰
- 延迟执行，性能更好
- 语法接近 CommonJS

**缺点**：
- 学习成本较高
- 生态系统较小
- 已逐渐被 ES Module 替代

## 4. ES Module (ES6 模块)

**适用场景**：现代浏览器和 Node.js

ES Module 是 JavaScript 语言层面的模块化标准，是目前的主流方案。

### 基本语法
```js
// math.js - 导出模块
export const add = (a, b) => a + b;
export const subtract = (a, b) => a - b;

// 默认导出
export default {
  multiply: (a, b) => a * b
};

// app.js - 导入模块
import { add, subtract } from './math.js';
import calculator from './math.js';

console.log(add(1, 2)); // 3
console.log(calculator.multiply(2, 3)); // 6
```

### 优缺点

**优点**：
- 语言原生支持，无需额外工具
- 支持静态分析和 tree-shaking
- 语法简洁优雅
- 支持异步加载（动态 import）

**缺点**：
- 旧浏览器不支持，需要转译
- 文件扩展名要求严格

## 5. UMD (Universal Module Definition)

**适用场景**：需要兼容多种环境的库

UMD 是一种兼容性方案，让同一个模块可以在不同环境中运行。

### 基本语法
```js
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD
    define(['exports'], factory);
  } else if (typeof module === 'object' && module.exports) {
    // CommonJS
    factory(module.exports);
  } else {
    // 浏览器全局变量
    factory(root.myLibrary = {});
  }
}(this, function (exports) {
  exports.add = (a, b) => a + b;
}));
```

### 优缺点

**优点**：
- 兼容性极好
- 一套代码多环境运行
- 适合开源库

**缺点**：
- 代码冗余，体积较大
- 维护复杂
- 不是长期解决方案

## 6. 循环依赖问题

**什么是循环依赖？**
循环依赖是指模块 A 依赖模块 B，同时模块 B 也依赖模块 A，形成相互依赖的情况。

### 各规范的处理方式

**CommonJS**：
- 返回部分导出的对象，可能导致 `undefined` 错误
- Node.js 会缓存模块，避免无限循环

**AMD**：
- 通过延迟执行和依赖注入来处理
- 可以使用 `require` 函数动态加载避免循环

**ES Module**：
- 支持循环依赖，但可能出现暂时性死区
- 建议重构代码避免循环依赖

### 最佳实践

1. **重构代码结构**：将共同依赖提取到独立模块
2. **使用依赖注入**：通过参数传递依赖
3. **延迟加载**：在需要时才加载模块

## 7. 模块化方案对比总结

| 特性 | CommonJS | AMD | CMD | ES Module | UMD |
|------|----------|-----|-----|-----------|-----|
| **环境** | Node.js | 浏览器 | 浏览器 | 通用 | 通用 |
| **加载方式** | 同步 | 异步 | 异步 | 同步/异步 | 兼容多种 |
| **语法复杂度** | 简单 | 复杂 | 中等 | 简单 | 复杂 |
| **静态分析** | ❌ | ❌ | ❌ | ✅ | ❌ |
| **Tree Shaking** | ❌ | ❌ | ❌ | ✅ | ❌ |
| **浏览器支持** | 需要打包 | 需要加载器 | 需要加载器 | 现代浏览器 | 原生支持 |
| **性能** | 好 | 中等 | 中等 | 最好 | 中等 |
| **生态成熟度** | 高 | 中等 | 低 | 高 | 中等 |

## 8. 选择建议

### 新项目推荐
- **首选 ES Module**：现代标准，功能最完善
- **配合打包工具**：如 Webpack、Vite 等处理兼容性

### 特殊场景
- **Node.js 项目**：CommonJS 或 ES Module
- **库开发**：UMD 保证最大兼容性
- **老项目维护**：根据现有技术栈选择

### 迁移策略
1. **逐步迁移**：从新模块开始使用 ES Module
2. **工具支持**：使用 Babel 等转译工具
3. **混合使用**：在过渡期可以多种规范并存

## 总结

前端模块化经历了从无到有、从简单到复杂、再到标准化的发展过程。ES Module 作为语言标准，是未来的发展方向。但了解各种模块化方案的特点和适用场景，有助于我们在不同项目中做出合适的技术选择。

选择模块化方案时，要考虑项目需求、团队技术栈、浏览器兼容性等因素，没有银弹，只有最适合的方案。

