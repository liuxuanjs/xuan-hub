# 微前端沙箱隔离完整指南

微前端架构中最关键的技术挑战之一就是应用间的隔离问题。本文详细介绍如何实现一套完整、可靠、高性能的沙箱隔离方案。

## 📋 目录

- [核心概念](#核心概念)
- [JavaScript 沙箱](#javascript-沙箱)
- [CSS 样式隔离](#css-样式隔离)
- [资源生命周期管理](#资源生命周期管理)
- [事件和内存管理](#事件和内存管理)
- [完整沙箱实现](#完整沙箱实现)
- [最佳实践](#最佳实践)
- [性能优化](#性能优化)
- [常见问题](#常见问题)

## 核心概念

### 沙箱隔离的必要性

在微前端架构中，多个独立的应用运行在同一个页面环境中，会面临以下问题：

```javascript
// 问题示例：全局变量冲突
// 主应用
window.userInfo = { name: 'admin', role: 'admin' };
window.config = { theme: 'light', version: '1.0' };

// 子应用 A
window.userInfo = { name: 'user1', role: 'user' };  // ❌ 覆盖主应用
window.config.theme = 'dark';                       // ❌ 修改主应用配置
window.appAData = 'sensitive data';                 // ❌ 污染全局

// 子应用 B 受到影响
console.log(window.userInfo);  // 不是期望的值
console.log(window.config);    // 被修改的配置
```

### 隔离原则

1. **状态隔离**：每个应用有独立的全局状态
2. **样式隔离**：CSS 规则不会相互影响
3. **事件隔离**：事件监听器不会泄漏
4. **资源隔离**：动态加载的资源能够正确清理
5. **副作用隔离**：定时器、网络请求等副作用能够完全清理

## JavaScript 沙箱

### 1. 快照沙箱（SnapshotSandbox）

适用于单实例场景，通过记录和恢复 window 对象的快照来实现隔离。

```javascript
/**
 * 快照沙箱 - 适用于单实例应用
 * 原理：记录激活前的 window 状态，恢复时回滚所有变更
 */
class SnapshotSandbox {
  constructor(name) {
    this.name = name;
    this.windowSnapshot = {};
    this.modifyPropsMap = {};
    this.active = false;
  }

  /**
   * 激活沙箱
   */
  activate() {
    if (this.active) return;

    // 记录当前 window 状态快照
    this.windowSnapshot = {};
    for (const prop in window) {
      if (window.hasOwnProperty(prop)) {
        this.windowSnapshot[prop] = window[prop];
      }
    }

    // 恢复之前的修改
    Object.keys(this.modifyPropsMap).forEach(prop => {
      window[prop] = this.modifyPropsMap[prop];
    });

    this.active = true;
    console.log(`🟢 ${this.name} 沙箱已激活`);
  }

  /**
   * 失活沙箱
   */
  deactivate() {
    if (!this.active) return;

    // 记录本次运行中的修改
    this.modifyPropsMap = {};
    for (const prop in window) {
      if (window.hasOwnProperty(prop)) {
        if (window[prop] !== this.windowSnapshot[prop]) {
          // 记录被修改的属性
          this.modifyPropsMap[prop] = window[prop];
          // 恢复到激活前的状态
          window[prop] = this.windowSnapshot[prop];
        }
      }
    }

    // 处理新增的属性
    for (const prop in window) {
      if (window.hasOwnProperty(prop) && !(prop in this.windowSnapshot)) {
        // 记录新增的属性
        this.modifyPropsMap[prop] = window[prop];
        // 删除新增的属性
        delete window[prop];
      }
    }

    this.active = false;
    console.log(`🔴 ${this.name} 沙箱已失活`);
  }

  /**
   * 获取沙箱状态
   */
  getStatus() {
    return {
      name: this.name,
      active: this.active,
      modifiedProps: Object.keys(this.modifyPropsMap).length,
      snapshotSize: Object.keys(this.windowSnapshot).length
    };
  }
}
```

### 2. 代理沙箱（ProxySandbox）

适用于多实例场景，通过 Proxy 拦截对 window 的访问，每个应用有独立的属性空间。

```javascript
/**
 * 代理沙箱 - 适用于多实例应用
 * 原理：通过 Proxy 拦截 window 访问，为每个应用创建独立的属性空间
 */
class ProxySandbox {
  constructor(name) {
    this.name = name;
    this.fakeWindow = {};
    this.active = false;
    this.injectedKeys = new Set();
    
    // 创建代理 window
    this.proxyWindow = this.createProxyWindow();
  }

  /**
   * 创建代理 window 对象
   */
  createProxyWindow() {
    const { fakeWindow, injectedKeys } = this;
    const descriptorTargetMap = new Map();
    
    return new Proxy(fakeWindow, {
      set: (target, prop, value, receiver) => {
        if (this.active) {
          if (!target.hasOwnProperty(prop) && window.hasOwnProperty(prop)) {
            // 如果是第一次设置且原 window 上存在该属性，记录原始描述符
            const descriptor = Object.getOwnPropertyDescriptor(window, prop);
            if (descriptor && !descriptor.configurable) {
              // 不可配置的属性不能被代理
              console.warn(`属性 ${prop} 不可配置，无法代理`);
              return false;
            }
            descriptorTargetMap.set(prop, descriptor);
          }
          
          injectedKeys.add(prop);
          target[prop] = value;
          
          console.log(`📝 ${this.name} 设置属性: ${prop}`, value);
          return true;
        }
        
        console.warn(`⚠️ ${this.name} 沙箱未激活，忽略设置: ${prop}`);
        return true;
      },

      get: (target, prop, receiver) => {
        // 优先从沙箱获取
        if (prop in target) {
          return target[prop];
        }

        // 从原始 window 获取
        const value = window[prop];
        
        // 绑定函数的 this 指向原始 window
        if (typeof value === 'function' && !this.isConstructor(value)) {
          return value.bind(window);
        }

        return value;
      },

      has: (target, prop) => {
        return prop in target || prop in window;
      },

      getOwnPropertyDescriptor: (target, prop) => {
        if (target.hasOwnProperty(prop)) {
          return Object.getOwnPropertyDescriptor(target, prop);
        }
        
        if (descriptorTargetMap.has(prop)) {
          return descriptorTargetMap.get(prop);
        }
        
        return Object.getOwnPropertyDescriptor(window, prop);
      },

      defineProperty: (target, prop, descriptor) => {
        if (this.active) {
          injectedKeys.add(prop);
          return Reflect.defineProperty(target, prop, descriptor);
        }
        return true;
      },

      deleteProperty: (target, prop) => {
        if (this.active) {
          injectedKeys.add(prop);
          return Reflect.deleteProperty(target, prop);
        }
        return true;
      },

      ownKeys: (target) => {
        return Reflect.ownKeys(window).concat(Reflect.ownKeys(target));
      }
    });
  }

  /**
   * 判断是否为构造函数
   */
  isConstructor(fn) {
    const functionStr = fn.toString();
    return /^class\s/.test(functionStr) || /^function\s+[A-Z]/.test(functionStr);
  }

  /**
   * 激活沙箱
   */
  activate() {
    if (this.active) return;
    
    this.active = true;
    console.log(`🟢 ${this.name} 代理沙箱已激活`);
  }

  /**
   * 失活沙箱
   */
  deactivate() {
    if (!this.active) return;
    
    this.active = false;
    console.log(`🔴 ${this.name} 代理沙箱已失活`);
  }

  /**
   * 获取代理 window
   */
  getProxyWindow() {
    return this.proxyWindow;
  }

  /**
   * 清理沙箱
   */
  destroy() {
    this.deactivate();
    this.fakeWindow = {};
    this.injectedKeys.clear();
    console.log(`🗑️ ${this.name} 沙箱已销毁`);
  }

  /**
   * 获取沙箱状态
   */
  getStatus() {
    return {
      name: this.name,
      active: this.active,
      injectedKeys: Array.from(this.injectedKeys),
      fakeWindowKeys: Object.keys(this.fakeWindow)
    };
  }
}
```

### 3. 原生沙箱（NativeSandbox）

使用 iframe 或 Web Workers 创建真正的隔离环境。

```javascript
/**
 * 原生沙箱 - 使用 iframe 实现真正的隔离
 */
class NativeSandbox {
  constructor(name) {
    this.name = name;
    this.iframe = null;
    this.sandboxWindow = null;
    this.active = false;
    this.messageHandlers = new Map();
  }

  /**
   * 创建沙箱环境
   */
  async create() {
    return new Promise((resolve, reject) => {
      // 创建隐藏的 iframe
      this.iframe = document.createElement('iframe');
      this.iframe.style.display = 'none';
      this.iframe.src = 'about:blank';
      
      this.iframe.onload = () => {
        try {
          this.sandboxWindow = this.iframe.contentWindow;
          this.setupSandboxEnvironment();
          console.log(`🏗️ ${this.name} 原生沙箱创建成功`);
          resolve(this.sandboxWindow);
        } catch (error) {
          console.error(`❌ ${this.name} 原生沙箱创建失败:`, error);
          reject(error);
        }
      };

      this.iframe.onerror = reject;
      document.body.appendChild(this.iframe);
    });
  }

  /**
   * 设置沙箱环境
   */
  setupSandboxEnvironment() {
    if (!this.sandboxWindow) return;

    // 注入必要的全局对象
    this.sandboxWindow.console = window.console;
    this.sandboxWindow.fetch = window.fetch.bind(window);
    this.sandboxWindow.setTimeout = window.setTimeout.bind(window);
    this.sandboxWindow.setInterval = window.setInterval.bind(window);
    this.sandboxWindow.clearTimeout = window.clearTimeout.bind(window);
    this.sandboxWindow.clearInterval = window.clearInterval.bind(window);
    
    // 设置通信机制
    this.setupCommunication();
    
    // 注入沙箱标识
    this.sandboxWindow.__SANDBOX_NAME__ = this.name;
    this.sandboxWindow.__IS_SANDBOX__ = true;
  }

  /**
   * 设置通信机制
   */
  setupCommunication() {
    // 监听来自沙箱的消息
    window.addEventListener('message', (event) => {
      if (event.source === this.sandboxWindow) {
        const { type, data, id } = event.data;
        
        if (this.messageHandlers.has(type)) {
          const handler = this.messageHandlers.get(type);
          const result = handler(data);
          
          // 发送响应
          this.sandboxWindow.postMessage({
            type: 'response',
            id,
            data: result
          }, '*');
        }
      }
    });

    // 为沙箱注入通信方法
    this.sandboxWindow.sendToHost = (type, data) => {
      return new Promise((resolve) => {
        const id = Math.random().toString(36).substr(2, 9);
        
        const responseHandler = (event) => {
          if (event.data.type === 'response' && event.data.id === id) {
            window.removeEventListener('message', responseHandler);
            resolve(event.data.data);
          }
        };
        
        window.addEventListener('message', responseHandler);
        
        window.postMessage({
          type,
          data,
          id
        }, '*');
      });
    };
  }

  /**
   * 注册消息处理器
   */
  onMessage(type, handler) {
    this.messageHandlers.set(type, handler);
  }

  /**
   * 在沙箱中执行代码
   */
  execute(code) {
    if (!this.sandboxWindow) {
      throw new Error('沙箱未创建');
    }

    try {
      return this.sandboxWindow.eval(code);
    } catch (error) {
      console.error(`${this.name} 代码执行失败:`, error);
      throw error;
    }
  }

  /**
   * 激活沙箱
   */
  activate() {
    this.active = true;
    console.log(`🟢 ${this.name} 原生沙箱已激活`);
  }

  /**
   * 失活沙箱
   */
  deactivate() {
    this.active = false;
    console.log(`🔴 ${this.name} 原生沙箱已失活`);
  }

  /**
   * 销毁沙箱
   */
  destroy() {
    if (this.iframe && this.iframe.parentNode) {
      this.iframe.parentNode.removeChild(this.iframe);
    }
    
    this.iframe = null;
    this.sandboxWindow = null;
    this.messageHandlers.clear();
    this.active = false;
    
    console.log(`🗑️ ${this.name} 原生沙箱已销毁`);
  }

  /**
   * 获取沙箱状态
   */
  getStatus() {
    return {
      name: this.name,
      active: this.active,
      created: !!this.sandboxWindow,
      messageHandlers: Array.from(this.messageHandlers.keys())
    };
  }
}
```

## CSS 样式隔离

### 1. 命名空间隔离

通过为每个应用添加唯一的 CSS 命名空间来实现样式隔离。

```javascript
/**
 * CSS 命名空间隔离器
 */
class CSSNamespaceIsolation {
  constructor(appName) {
    this.appName = appName;
    this.namespace = `micro-app-${appName}`;
    this.dynamicStyles = [];
    this.originalStyles = [];
    this.isActive = false;
    this.observer = null;
  }

  /**
   * 激活样式隔离
   */
  activate(container) {
    if (this.isActive) return;

    console.log(`🎨 激活 ${this.appName} CSS 隔离`);

    // 为容器添加命名空间
    container.classList.add(this.namespace);
    
    // 记录现有样式
    this.recordExistingStyles();
    
    // 开始监听样式变化
    this.startStyleMonitoring();
    
    this.isActive = true;
  }

  /**
   * 失活样式隔离
   */
  deactivate(container) {
    if (!this.isActive) return;

    console.log(`🎨 失活 ${this.appName} CSS 隔离`);

    // 移除动态样式
    this.removeDynamicStyles();
    
    // 移除命名空间
    container.classList.remove(this.namespace);
    
    // 停止监听
    this.stopStyleMonitoring();
    
    this.isActive = false;
  }

  /**
   * 记录现有样式节点
   */
  recordExistingStyles() {
    this.originalStyles = Array.from(
      document.head.querySelectorAll('style, link[rel="stylesheet"]')
    );
    console.log(`📝 记录了 ${this.originalStyles.length} 个现有样式`);
  }

  /**
   * 开始监听样式变化
   */
  startStyleMonitoring() {
    this.observer = new MutationObserver(mutations => {
      mutations.forEach(mutation => {
        mutation.addedNodes.forEach(node => {
          if (this.isStyleNode(node) && !this.isOriginalStyle(node)) {
            this.handleNewStyleNode(node);
          }
        });
      });
    });

    this.observer.observe(document.head, {
      childList: true,
      subtree: true
    });
  }

  /**
   * 停止监听样式变化
   */
  stopStyleMonitoring() {
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
    }
  }

  /**
   * 判断是否为样式节点
   */
  isStyleNode(node) {
    return node.nodeType === Node.ELEMENT_NODE && 
           (node.tagName === 'STYLE' || 
            (node.tagName === 'LINK' && node.rel === 'stylesheet'));
  }

  /**
   * 判断是否为原始样式
   */
  isOriginalStyle(node) {
    return this.originalStyles.includes(node);
  }

  /**
   * 处理新增的样式节点
   */
  handleNewStyleNode(node) {
    // 标记样式属于当前应用
    node.setAttribute('data-micro-app', this.appName);
    this.dynamicStyles.push(node);

    if (node.tagName === 'STYLE') {
      this.processStyleContent(node);
    } else if (node.tagName === 'LINK') {
      this.processLinkStylesheet(node);
    }
  }

  /**
   * 处理 style 标签内容
   */
  processStyleContent(styleNode) {
    try {
      const originalCSS = styleNode.textContent || styleNode.innerHTML;
      if (!originalCSS.trim()) return;

      const namespacedCSS = this.addNamespaceToCSS(originalCSS);
      styleNode.textContent = namespacedCSS;
      
      console.log(`✅ 已为样式添加命名空间`);
    } catch (error) {
      console.warn(`⚠️ 处理样式内容失败:`, error);
    }
  }

  /**
   * 处理 link 样式表
   */
  async processLinkStylesheet(linkNode) {
    if (!linkNode.href || linkNode.href.startsWith('data:')) return;

    try {
      const response = await fetch(linkNode.href);
      const cssText = await response.text();
      
      // 创建新的 style 标签替代
      const styleNode = document.createElement('style');
      styleNode.setAttribute('data-micro-app', this.appName);
      styleNode.setAttribute('data-original-href', linkNode.href);
      styleNode.textContent = this.addNamespaceToCSS(cssText);
      
      // 替换原来的 link 标签
      linkNode.parentNode.insertBefore(styleNode, linkNode);
      linkNode.parentNode.removeChild(linkNode);
      
      // 更新动态样式列表
      const linkIndex = this.dynamicStyles.indexOf(linkNode);
      if (linkIndex > -1) {
        this.dynamicStyles[linkIndex] = styleNode;
      }
      
      console.log(`✅ 已处理外部样式表: ${linkNode.href}`);
    } catch (error) {
      console.warn(`⚠️ 处理外部样式表失败:`, error);
    }
  }

  /**
   * 为 CSS 添加命名空间
   */
  addNamespaceToCSS(cssText) {
    // 使用正则表达式处理选择器
    return cssText.replace(/([^{}]+)\s*\{/g, (match, selectors) => {
      // 跳过 @规则（如 @media, @keyframes 等）
      if (selectors.trim().startsWith('@')) {
        return match;
      }

      // 处理多个选择器（逗号分隔）
      const processedSelectors = selectors
        .split(',')
        .map(selector => this.addNamespaceToSelector(selector.trim()))
        .join(', ');

      return `${processedSelectors} {`;
    });
  }

  /**
   * 为单个选择器添加命名空间
   */
  addNamespaceToSelector(selector) {
    // 处理特殊选择器
    if (selector === 'html' || selector === 'body') {
      return `.${this.namespace}`;
    }

    if (selector.startsWith('html ') || selector.startsWith('body ')) {
      return selector.replace(/^(html|body)\s*/, `.${this.namespace} `);
    }

    // 如果已包含命名空间，跳过
    if (selector.includes(`.${this.namespace}`)) {
      return selector;
    }

    // 处理伪类和伪元素
    const pseudoRegex = /^([^:]+)(:.*)$/;
    const pseudoMatch = selector.match(pseudoRegex);
    
    if (pseudoMatch) {
      const [, baseSelector, pseudo] = pseudoMatch;
      return `.${this.namespace} ${baseSelector}${pseudo}`;
    }

    // 普通选择器
    return `.${this.namespace} ${selector}`;
  }

  /**
   * 移除动态样式
   */
  removeDynamicStyles() {
    console.log(`🗑️ 清理 ${this.appName} 的 ${this.dynamicStyles.length} 个样式`);
    
    this.dynamicStyles.forEach(styleNode => {
      if (styleNode && styleNode.parentNode) {
        styleNode.parentNode.removeChild(styleNode);
      }
    });
    
    this.dynamicStyles = [];
  }

  /**
   * 获取样式统计
   */
  getStats() {
    return {
      appName: this.appName,
      namespace: this.namespace,
      isActive: this.isActive,
      dynamicStyles: this.dynamicStyles.length,
      originalStyles: this.originalStyles.length
    };
  }
}
```

### 2. Shadow DOM 隔离

使用 Shadow DOM 实现真正的样式隔离。

```javascript
/**
 * Shadow DOM 样式隔离器
 */
class ShadowDOMIsolation {
  constructor(appName) {
    this.appName = appName;
    this.shadowHost = null;
    this.shadowRoot = null;
    this.isActive = false;
  }

  /**
   * 创建 Shadow DOM
   */
  create(container) {
    if (this.shadowRoot) {
      console.warn(`${this.appName} Shadow DOM 已存在`);
      return this.shadowRoot;
    }

    try {
      // 创建 shadow host
      this.shadowHost = document.createElement('div');
      this.shadowHost.setAttribute('data-micro-app', this.appName);
      
      // 创建 shadow root
      this.shadowRoot = this.shadowHost.attachShadow({ mode: 'open' });
      
      // 创建应用容器
      const appContainer = document.createElement('div');
      appContainer.id = 'app-root';
      appContainer.style.cssText = `
        width: 100%;
        height: 100%;
        position: relative;
      `;
      
      this.shadowRoot.appendChild(appContainer);
      container.appendChild(this.shadowHost);
      
      console.log(`🌟 ${this.appName} Shadow DOM 创建成功`);
      return this.shadowRoot;
    } catch (error) {
      console.error(`❌ ${this.appName} Shadow DOM 创建失败:`, error);
      throw error;
    }
  }

  /**
   * 激活 Shadow DOM 隔离
   */
  activate() {
    if (this.isActive || !this.shadowRoot) return;
    
    this.isActive = true;
    console.log(`🟢 ${this.appName} Shadow DOM 隔离已激活`);
  }

  /**
   * 失活 Shadow DOM 隔离
   */
  deactivate() {
    if (!this.isActive) return;
    
    this.isActive = false;
    console.log(`🔴 ${this.appName} Shadow DOM 隔离已失活`);
  }

  /**
   * 添加样式到 Shadow DOM
   */
  addStyle(cssText) {
    if (!this.shadowRoot) return;

    const style = document.createElement('style');
    style.textContent = cssText;
    this.shadowRoot.appendChild(style);
    
    console.log(`📝 已添加样式到 ${this.appName} Shadow DOM`);
  }

  /**
   * 添加外部样式表到 Shadow DOM
   */
  addStylesheet(href) {
    if (!this.shadowRoot) return;

    const link = document.createElement('link');
    link.rel = 'stylesheet';
    link.href = href;
    this.shadowRoot.appendChild(link);
    
    console.log(`🔗 已添加样式表到 ${this.appName} Shadow DOM: ${href}`);
  }

  /**
   * 获取应用容器
   */
  getContainer() {
    return this.shadowRoot ? this.shadowRoot.querySelector('#app-root') : null;
  }

  /**
   * 销毁 Shadow DOM
   */
  destroy() {
    if (this.shadowHost && this.shadowHost.parentNode) {
      this.shadowHost.parentNode.removeChild(this.shadowHost);
    }
    
    this.shadowHost = null;
    this.shadowRoot = null;
    this.isActive = false;
    
    console.log(`🗑️ ${this.appName} Shadow DOM 已销毁`);
  }

  /**
   * 获取状态
   */
  getStatus() {
    return {
      appName: this.appName,
      isActive: this.isActive,
      created: !!this.shadowRoot,
      host: this.shadowHost,
      root: this.shadowRoot
    };
  }
}
```

## 资源生命周期管理

### 应用清理器

确保应用卸载时能够完全清理所有资源。

```javascript
/**
 * 应用资源清理器
 * 核心思路：记录所有副作用，卸载时统一清理
 */
class ApplicationCleaner {
  constructor(appName) {
    this.appName = appName;
    this.resources = {
      eventListeners: [],
      timers: [],
      intervals: [],
      observers: [],
      requestCallbacks: [],
      styleSheets: [],
      scripts: [],
      customElements: []
    };
    this.originalMethods = {};
    this.active = false;
  }

  /**
   * 激活资源追踪
   */
  activate() {
    if (this.active) return;

    this.hookGlobalMethods();
    this.active = true;
    
    console.log(`🔍 ${this.appName} 资源追踪已激活`);
  }

  /**
   * 钩子全局方法
   */
  hookGlobalMethods() {
    // 钩子 addEventListener
    this.hookAddEventListener();
    
    // 钩子定时器
    this.hookTimers();
    
    // 钩子观察者
    this.hookObservers();
    
    // 钩子请求方法
    this.hookRequestMethods();
  }

  /**
   * 钩子事件监听器
   */
  hookAddEventListener() {
    const { resources } = this;
    
    // 保存原始方法
    this.originalMethods.addEventListener = EventTarget.prototype.addEventListener;
    this.originalMethods.removeEventListener = EventTarget.prototype.removeEventListener;
    
    // 重写 addEventListener
    EventTarget.prototype.addEventListener = function(type, listener, options) {
      // 记录事件监听器
      resources.eventListeners.push({
        target: this,
        type,
        listener,
        options
      });
      
      return this.originalMethods.addEventListener.call(this, type, listener, options);
    }.bind(this);
  }

  /**
   * 钩子定时器
   */
  hookTimers() {
    const { resources } = this;
    
    // 保存原始方法
    this.originalMethods.setTimeout = window.setTimeout;
    this.originalMethods.clearTimeout = window.clearTimeout;
    this.originalMethods.setInterval = window.setInterval;
    this.originalMethods.clearInterval = window.clearInterval;
    
    // 重写 setTimeout
    window.setTimeout = (callback, delay, ...args) => {
      const id = this.originalMethods.setTimeout(callback, delay, ...args);
      resources.timers.push(id);
      return id;
    };
    
    // 重写 setInterval
    window.setInterval = (callback, delay, ...args) => {
      const id = this.originalMethods.setInterval(callback, delay, ...args);
      resources.intervals.push(id);
      return id;
    };
  }

  /**
   * 钩子观察者
   */
  hookObservers() {
    const { resources } = this;
    
    // MutationObserver
    const OriginalMutationObserver = window.MutationObserver;
    window.MutationObserver = function(...args) {
      const observer = new OriginalMutationObserver(...args);
      resources.observers.push(observer);
      return observer;
    };
    
    // IntersectionObserver
    const OriginalIntersectionObserver = window.IntersectionObserver;
    window.IntersectionObserver = function(...args) {
      const observer = new OriginalIntersectionObserver(...args);
      resources.observers.push(observer);
      return observer;
    };
    
    // ResizeObserver
    if (window.ResizeObserver) {
      const OriginalResizeObserver = window.ResizeObserver;
      window.ResizeObserver = function(...args) {
        const observer = new OriginalResizeObserver(...args);
        resources.observers.push(observer);
        return observer;
      };
    }
  }

  /**
   * 钩子请求方法
   */
  hookRequestMethods() {
    const { resources } = this;
    
    // requestAnimationFrame
    this.originalMethods.requestAnimationFrame = window.requestAnimationFrame;
    this.originalMethods.cancelAnimationFrame = window.cancelAnimationFrame;
    
    window.requestAnimationFrame = (callback) => {
      const id = this.originalMethods.requestAnimationFrame(callback);
      resources.requestCallbacks.push(id);
      return id;
    };
    
    // requestIdleCallback
    if (window.requestIdleCallback) {
      this.originalMethods.requestIdleCallback = window.requestIdleCallback;
      this.originalMethods.cancelIdleCallback = window.cancelIdleCallback;
      
      window.requestIdleCallback = (callback, options) => {
        const id = this.originalMethods.requestIdleCallback(callback, options);
        resources.requestCallbacks.push(id);
        return id;
      };
    }
  }

  /**
   * 添加样式表
   */
  addStyleSheet(element) {
    this.resources.styleSheets.push(element);
  }

  /**
   * 添加脚本
   */
  addScript(element) {
    this.resources.scripts.push(element);
  }

  /**
   * 失活并清理所有资源
   */
  deactivate() {
    if (!this.active) return;

    console.log(`🧹 开始清理 ${this.appName} 的资源`);
    
    this.cleanupResources();
    this.restoreGlobalMethods();
    
    this.active = false;
    console.log(`✅ ${this.appName} 资源清理完成`);
  }

  /**
   * 清理资源
   */
  cleanupResources() {
    const { resources } = this;
    
    // 清理事件监听器
    resources.eventListeners.forEach(({ target, type, listener, options }) => {
      try {
        target.removeEventListener(type, listener, options);
      } catch (error) {
        console.warn('清理事件监听器失败:', error);
      }
    });
    
    // 清理定时器
    resources.timers.forEach(id => {
      this.originalMethods.clearTimeout(id);
    });
    
    resources.intervals.forEach(id => {
      this.originalMethods.clearInterval(id);
    });
    
    // 清理观察者
    resources.observers.forEach(observer => {
      try {
        observer.disconnect();
      } catch (error) {
        console.warn('清理观察者失败:', error);
      }
    });
    
    // 清理请求回调
    resources.requestCallbacks.forEach(id => {
      this.originalMethods.cancelAnimationFrame(id);
      if (this.originalMethods.cancelIdleCallback) {
        this.originalMethods.cancelIdleCallback(id);
      }
    });
    
    // 清理样式表
    resources.styleSheets.forEach(element => {
      if (element && element.parentNode) {
        element.parentNode.removeChild(element);
      }
    });
    
    // 清理脚本
    resources.scripts.forEach(element => {
      if (element && element.parentNode) {
        element.parentNode.removeChild(element);
      }
    });
    
    // 重置资源记录
    Object.keys(resources).forEach(key => {
      resources[key] = [];
    });
  }

  /**
   * 恢复全局方法
   */
  restoreGlobalMethods() {
    // 恢复事件方法
    if (this.originalMethods.addEventListener) {
      EventTarget.prototype.addEventListener = this.originalMethods.addEventListener;
      EventTarget.prototype.removeEventListener = this.originalMethods.removeEventListener;
    }
    
    // 恢复定时器方法
    if (this.originalMethods.setTimeout) {
      window.setTimeout = this.originalMethods.setTimeout;
      window.clearTimeout = this.originalMethods.clearTimeout;
      window.setInterval = this.originalMethods.setInterval;
      window.clearInterval = this.originalMethods.clearInterval;
    }
    
    // 恢复请求方法
    if (this.originalMethods.requestAnimationFrame) {
      window.requestAnimationFrame = this.originalMethods.requestAnimationFrame;
      window.cancelAnimationFrame = this.originalMethods.cancelAnimationFrame;
    }
    
    if (this.originalMethods.requestIdleCallback) {
      window.requestIdleCallback = this.originalMethods.requestIdleCallback;
      window.cancelIdleCallback = this.originalMethods.cancelIdleCallback;
    }
  }

  /**
   * 获取资源统计
   */
  getResourceStats() {
    const { resources } = this;
    
    return {
      appName: this.appName,
      active: this.active,
      eventListeners: resources.eventListeners.length,
      timers: resources.timers.length,
      intervals: resources.intervals.length,
      observers: resources.observers.length,
      requestCallbacks: resources.requestCallbacks.length,
      styleSheets: resources.styleSheets.length,
      scripts: resources.scripts.length,
      total: Object.values(resources).reduce((sum, arr) => sum + arr.length, 0)
    };
  }
}
```

## 事件和内存管理

### 内存泄漏检测器

```javascript
/**
 * 内存泄漏检测器
 */
class MemoryLeakDetector {
  constructor(appName) {
    this.appName = appName;
    this.memorySnapshots = [];
    this.leakThreshold = 50 * 1024 * 1024; // 50MB
    this.checkInterval = 30000; // 30秒检查一次
    this.checking = false;
    this.detectedLeaks = [];
  }

  /**
   * 开始内存监控
   */
  startMonitoring() {
    if (this.checking) return;
    
    this.checking = true;
    this.takeSnapshot('initial');
    
    this.checkTimer = setInterval(() => {
      this.checkMemoryUsage();
    }, this.checkInterval);
    
    console.log(`🔍 ${this.appName} 内存监控已启动`);
  }

  /**
   * 停止内存监控
   */
  stopMonitoring() {
    if (!this.checking) return;
    
    this.checking = false;
    
    if (this.checkTimer) {
      clearInterval(this.checkTimer);
      this.checkTimer = null;
    }
    
    this.takeSnapshot('final');
    this.generateReport();
    
    console.log(`🔍 ${this.appName} 内存监控已停止`);
  }

  /**
   * 获取内存信息
   */
  getMemoryInfo() {
    if (performance.memory) {
      return {
        usedJSHeapSize: performance.memory.usedJSHeapSize,
        totalJSHeapSize: performance.memory.totalJSHeapSize,
        jsHeapSizeLimit: performance.memory.jsHeapSizeLimit,
        timestamp: Date.now()
      };
    }
    
    return {
      usedJSHeapSize: 0,
      totalJSHeapSize: 0,
      jsHeapSizeLimit: 0,
      timestamp: Date.now()
    };
  }

  /**
   * 记录内存快照
   */
  takeSnapshot(label) {
    const memoryInfo = this.getMemoryInfo();
    
    this.memorySnapshots.push({
      label,
      ...memoryInfo
    });
    
    console.log(`📸 ${this.appName} 内存快照 [${label}]:`, 
               `${(memoryInfo.usedJSHeapSize / 1024 / 1024).toFixed(2)}MB`);
  }

  /**
   * 检查内存使用情况
   */
  checkMemoryUsage() {
    const currentMemory = this.getMemoryInfo();
    const lastSnapshot = this.memorySnapshots[this.memorySnapshots.length - 1];
    
    if (lastSnapshot) {
      const memoryIncrease = currentMemory.usedJSHeapSize - lastSnapshot.usedJSHeapSize;
      
      // 检测内存增长
      if (memoryIncrease > this.leakThreshold) {
        this.detectLeak(memoryIncrease, currentMemory);
      }
    }
    
    this.takeSnapshot('check');
    
    // 保持快照数量在合理范围内
    if (this.memorySnapshots.length > 50) {
      this.memorySnapshots.shift();
    }
  }

  /**
   * 检测内存泄漏
   */
  detectLeak(increase, currentMemory) {
    const leak = {
      appName: this.appName,
      timestamp: Date.now(),
      memoryIncrease: increase,
      currentUsage: currentMemory.usedJSHeapSize,
      severity: this.calculateSeverity(increase)
    };
    
    this.detectedLeaks.push(leak);
    
    console.warn(`🚨 ${this.appName} 检测到内存泄漏:`, 
                `增长 ${(increase / 1024 / 1024).toFixed(2)}MB`,
                `当前使用 ${(currentMemory.usedJSHeapSize / 1024 / 1024).toFixed(2)}MB`);
    
    // 触发垃圾回收（如果可用）
    if (window.gc) {
      window.gc();
    }
  }

  /**
   * 计算泄漏严重程度
   */
  calculateSeverity(increase) {
    if (increase > 100 * 1024 * 1024) return 'critical';
    if (increase > 50 * 1024 * 1024) return 'high';
    if (increase > 20 * 1024 * 1024) return 'medium';
    return 'low';
  }

  /**
   * 生成内存报告
   */
  generateReport() {
    const report = {
      appName: this.appName,
      snapshots: this.memorySnapshots,
      leaks: this.detectedLeaks,
      summary: this.generateSummary()
    };
    
    console.log(`📊 ${this.appName} 内存使用报告:`, report);
    return report;
  }

  /**
   * 生成摘要
   */
  generateSummary() {
    if (this.memorySnapshots.length < 2) {
      return { status: 'insufficient_data' };
    }
    
    const initial = this.memorySnapshots[0];
    const final = this.memorySnapshots[this.memorySnapshots.length - 1];
    const totalIncrease = final.usedJSHeapSize - initial.usedJSHeapSize;
    
    return {
      initialMemory: initial.usedJSHeapSize,
      finalMemory: final.usedJSHeapSize,
      totalIncrease,
      leakCount: this.detectedLeaks.length,
      status: this.detectedLeaks.length > 0 ? 'leaks_detected' : 'clean'
    };
  }
}
```

## 完整沙箱实现

### 统一沙箱管理器

```javascript
/**
 * 完整的微前端沙箱管理器
 * 集成所有隔离功能
 */
class MicroFrontendSandbox {
  constructor(appName, options = {}) {
    this.appName = appName;
    this.options = {
      enableJSIsolation: true,
      enableCSSIsolation: true,
      enableResourceTracking: true,
      enableMemoryMonitoring: false,
      sandboxType: 'proxy', // 'snapshot' | 'proxy' | 'native' | 'shadow'
      ...options
    };
    
    this.container = null;
    this.jsSandbox = null;
    this.cssIsolation = null;
    this.resourceCleaner = null;
    this.memoryDetector = null;
    this.isActive = false;
    
    this.initializeSandbox();
  }

  /**
   * 初始化沙箱
   */
  initializeSandbox() {
    const { options, appName } = this;
    
    // 初始化 JavaScript 沙箱
    if (options.enableJSIsolation) {
      switch (options.sandboxType) {
        case 'snapshot':
          this.jsSandbox = new SnapshotSandbox(appName);
          break;
        case 'proxy':
          this.jsSandbox = new ProxySandbox(appName);
          break;
        case 'native':
          this.jsSandbox = new NativeSandbox(appName);
          break;
        default:
          this.jsSandbox = new ProxySandbox(appName);
      }
    }
    
    // 初始化 CSS 隔离
    if (options.enableCSSIsolation) {
      if (options.sandboxType === 'shadow') {
        this.cssIsolation = new ShadowDOMIsolation(appName);
      } else {
        this.cssIsolation = new CSSNamespaceIsolation(appName);
      }
    }
    
    // 初始化资源清理器
    if (options.enableResourceTracking) {
      this.resourceCleaner = new ApplicationCleaner(appName);
    }
    
    // 初始化内存监控
    if (options.enableMemoryMonitoring) {
      this.memoryDetector = new MemoryLeakDetector(appName);
    }
    
    console.log(`🏗️ ${appName} 沙箱初始化完成`, this.options);
  }

  /**
   * 设置容器
   */
  setContainer(container) {
    this.container = container;
    
    // 为 Shadow DOM 创建隔离环境
    if (this.options.sandboxType === 'shadow' && this.cssIsolation) {
      const shadowRoot = this.cssIsolation.create(container);
      this.container = this.cssIsolation.getContainer();
    }
  }

  /**
   * 激活沙箱
   */
  async activate() {
    if (this.isActive) return;
    
    console.log(`🟢 激活 ${this.appName} 沙箱`);
    
    try {
      // 激活 JavaScript 沙箱
      if (this.jsSandbox) {
        if (this.jsSandbox.create) {
          await this.jsSandbox.create();
        }
        this.jsSandbox.activate();
      }
      
      // 激活 CSS 隔离
      if (this.cssIsolation && this.container) {
        this.cssIsolation.activate(this.container);
      }
      
      // 激活资源追踪
      if (this.resourceCleaner) {
        this.resourceCleaner.activate();
      }
      
      // 开始内存监控
      if (this.memoryDetector) {
        this.memoryDetector.startMonitoring();
      }
      
      this.isActive = true;
      console.log(`✅ ${this.appName} 沙箱激活完成`);
      
    } catch (error) {
      console.error(`❌ ${this.appName} 沙箱激活失败:`, error);
      throw error;
    }
  }

  /**
   * 失活沙箱
   */
  async deactivate() {
    if (!this.isActive) return;
    
    console.log(`🔴 失活 ${this.appName} 沙箱`);
    
    try {
      // 停止内存监控
      if (this.memoryDetector) {
        this.memoryDetector.stopMonitoring();
      }
      
      // 清理资源
      if (this.resourceCleaner) {
        this.resourceCleaner.deactivate();
      }
      
      // 失活 CSS 隔离
      if (this.cssIsolation) {
        if (this.cssIsolation.deactivate) {
          this.cssIsolation.deactivate(this.container);
        }
      }
      
      // 失活 JavaScript 沙箱
      if (this.jsSandbox) {
        this.jsSandbox.deactivate();
      }
      
      this.isActive = false;
      console.log(`✅ ${this.appName} 沙箱失活完成`);
      
    } catch (error) {
      console.error(`❌ ${this.appName} 沙箱失活失败:`, error);
      throw error;
    }
  }

  /**
   * 销毁沙箱
   */
  async destroy() {
    await this.deactivate();
    
    // 销毁所有组件
    if (this.jsSandbox && this.jsSandbox.destroy) {
      this.jsSandbox.destroy();
    }
    
    if (this.cssIsolation && this.cssIsolation.destroy) {
      this.cssIsolation.destroy();
    }
    
    this.jsSandbox = null;
    this.cssIsolation = null;
    this.resourceCleaner = null;
    this.memoryDetector = null;
    this.container = null;
    
    console.log(`🗑️ ${this.appName} 沙箱已销毁`);
  }

  /**
   * 获取代理 window（如果支持）
   */
  getProxyWindow() {
    if (this.jsSandbox && this.jsSandbox.getProxyWindow) {
      return this.jsSandbox.getProxyWindow();
    }
    return window;
  }

  /**
   * 获取应用容器
   */
  getContainer() {
    return this.container;
  }

  /**
   * 添加样式
   */
  addStyle(cssText) {
    if (this.cssIsolation && this.cssIsolation.addStyle) {
      this.cssIsolation.addStyle(cssText);
    }
  }

  /**
   * 添加样式表
   */
  addStylesheet(href) {
    if (this.cssIsolation && this.cssIsolation.addStylesheet) {
      this.cssIsolation.addStylesheet(href);
    }
  }

  /**
   * 获取沙箱状态
   */
  getStatus() {
    return {
      appName: this.appName,
      isActive: this.isActive,
      options: this.options,
      jsSandbox: this.jsSandbox ? this.jsSandbox.getStatus() : null,
      cssIsolation: this.cssIsolation ? this.cssIsolation.getStats() : null,
      resourceCleaner: this.resourceCleaner ? this.resourceCleaner.getResourceStats() : null,
      memoryDetector: this.memoryDetector ? this.memoryDetector.generateReport() : null
    };
  }

  /**
   * 运行代码在沙箱中
   */
  execute(code) {
    if (this.jsSandbox && this.jsSandbox.execute) {
      return this.jsSandbox.execute(code);
    }
    
    // 使用代理 window 执行
    const proxyWindow = this.getProxyWindow();
    return (function() {
      return eval(code);
    }).call(proxyWindow);
  }
}
```

## 最佳实践

### 1. 选择合适的沙箱策略

```javascript
/**
 * 沙箱策略选择器
 */
class SandboxStrategySelector {
  static selectStrategy(requirements) {
    const {
      multiInstance = false,
      strictIsolation = false,
      performance = 'medium',
      compatibility = 'modern',
      features = []
    } = requirements;
    
    // 严格隔离需求
    if (strictIsolation) {
      if (features.includes('shadow-dom') && compatibility === 'modern') {
        return 'shadow';
      }
      return 'native';
    }
    
    // 多实例需求
    if (multiInstance) {
      return 'proxy';
    }
    
    // 性能优先
    if (performance === 'high') {
      return 'snapshot';
    }
    
    // 默认策略
    return 'proxy';
  }
  
  static createSandbox(appName, requirements) {
    const strategy = this.selectStrategy(requirements);
    
    const options = {
      sandboxType: strategy,
      enableJSIsolation: true,
      enableCSSIsolation: !requirements.disableCSSIsolation,
      enableResourceTracking: true,
      enableMemoryMonitoring: requirements.enableMemoryMonitoring || false
    };
    
    return new MicroFrontendSandbox(appName, options);
  }
}

// 使用示例
const reactAppSandbox = SandboxStrategySelector.createSandbox('react-app', {
  multiInstance: true,
  performance: 'high',
  compatibility: 'modern',
  features: ['css-isolation', 'resource-tracking']
});

const vueAppSandbox = SandboxStrategySelector.createSandbox('vue-app', {
  strictIsolation: true,
  features: ['shadow-dom'],
  enableMemoryMonitoring: true
});
```

### 2. 性能监控和优化

```javascript
/**
 * 沙箱性能监控器
 */
class SandboxPerformanceMonitor {
  constructor() {
    this.metrics = new Map();
    this.observers = [];
  }

  /**
   * 监控沙箱性能
   */
  monitor(sandbox) {
    const appName = sandbox.appName;
    
    if (this.metrics.has(appName)) {
      return; // 已在监控中
    }
    
    const metrics = {
      activationTime: [],
      deactivationTime: [],
      memoryUsage: [],
      resourceCount: []
    };
    
    this.metrics.set(appName, metrics);
    
    // 监控激活时间
    const originalActivate = sandbox.activate.bind(sandbox);
    sandbox.activate = async () => {
      const start = performance.now();
      await originalActivate();
      const duration = performance.now() - start;
      
      metrics.activationTime.push(duration);
      console.log(`📊 ${appName} 激活耗时: ${duration.toFixed(2)}ms`);
    };
    
    // 监控失活时间
    const originalDeactivate = sandbox.deactivate.bind(sandbox);
    sandbox.deactivate = async () => {
      const start = performance.now();
      await originalDeactivate();
      const duration = performance.now() - start;
      
      metrics.deactivationTime.push(duration);
      console.log(`📊 ${appName} 失活耗时: ${duration.toFixed(2)}ms`);
    };
    
    // 定期收集资源使用情况
    const collectMetrics = () => {
      const status = sandbox.getStatus();
      
      if (status.resourceCleaner) {
        metrics.resourceCount.push(status.resourceCleaner.total);
      }
      
      if (performance.memory) {
        metrics.memoryUsage.push(performance.memory.usedJSHeapSize);
      }
    };
    
    const interval = setInterval(collectMetrics, 5000);
    this.observers.push(() => clearInterval(interval));
  }

  /**
   * 获取性能报告
   */
  getReport(appName) {
    const metrics = this.metrics.get(appName);
    if (!metrics) return null;
    
    const calculateStats = (arr) => {
      if (arr.length === 0) return { avg: 0, min: 0, max: 0, count: 0 };
      
      const sum = arr.reduce((a, b) => a + b, 0);
      return {
        avg: sum / arr.length,
        min: Math.min(...arr),
        max: Math.max(...arr),
        count: arr.length
      };
    };
    
    return {
      appName,
      activationTime: calculateStats(metrics.activationTime),
      deactivationTime: calculateStats(metrics.deactivationTime),
      resourceCount: calculateStats(metrics.resourceCount),
      memoryUsage: calculateStats(metrics.memoryUsage),
      timestamp: Date.now()
    };
  }

  /**
   * 获取所有应用的报告
   */
  getAllReports() {
    const reports = {};
    
    this.metrics.forEach((_, appName) => {
      reports[appName] = this.getReport(appName);
    });
    
    return reports;
  }

  /**
   * 清理监控
   */
  cleanup() {
    this.observers.forEach(cleanup => cleanup());
    this.observers = [];
    this.metrics.clear();
  }
}
```

### 3. 调试和开发工具

```javascript
/**
 * 沙箱调试工具
 */
class SandboxDebugger {
  constructor() {
    this.sandboxes = new Map();
    this.history = [];
    this.maxHistorySize = 1000;
    
    this.setupGlobalDebugger();
  }

  /**
   * 注册沙箱
   */
  register(sandbox) {
    this.sandboxes.set(sandbox.appName, sandbox);
    this.log('register', sandbox.appName);
  }

  /**
   * 注销沙箱
   */
  unregister(appName) {
    this.sandboxes.delete(appName);
    this.log('unregister', appName);
  }

  /**
   * 记录日志
   */
  log(action, appName, data = {}) {
    const entry = {
      timestamp: Date.now(),
      action,
      appName,
      data
    };
    
    this.history.push(entry);
    
    if (this.history.length > this.maxHistorySize) {
      this.history.shift();
    }
    
    console.log(`🔧 [Sandbox Debug] ${action}: ${appName}`, data);
  }

  /**
   * 设置全局调试器
   */
  setupGlobalDebugger() {
    window.__SANDBOX_DEBUGGER__ = {
      // 获取所有沙箱状态
      getAllStatus: () => {
        const status = {};
        this.sandboxes.forEach((sandbox, name) => {
          status[name] = sandbox.getStatus();
        });
        return status;
      },
      
      // 获取特定沙箱状态
      getStatus: (appName) => {
        const sandbox = this.sandboxes.get(appName);
        return sandbox ? sandbox.getStatus() : null;
      },
      
      // 强制激活沙箱
      activate: (appName) => {
        const sandbox = this.sandboxes.get(appName);
        if (sandbox) {
          return sandbox.activate();
        }
        throw new Error(`沙箱 ${appName} 不存在`);
      },
      
      // 强制失活沙箱
      deactivate: (appName) => {
        const sandbox = this.sandboxes.get(appName);
        if (sandbox) {
          return sandbox.deactivate();
        }
        throw new Error(`沙箱 ${appName} 不存在`);
      },
      
      // 获取调试历史
      getHistory: (appName) => {
        if (appName) {
          return this.history.filter(entry => entry.appName === appName);
        }
        return this.history;
      },
      
      // 清理调试历史
      clearHistory: () => {
        this.history = [];
      },
      
      // 导出沙箱状态
      exportStatus: () => {
        return JSON.stringify(this.getAllStatus(), null, 2);
      },
      
      // 检查内存泄漏
      checkMemoryLeaks: () => {
        const reports = {};
        this.sandboxes.forEach((sandbox, name) => {
          if (sandbox.memoryDetector) {
            reports[name] = sandbox.memoryDetector.generateReport();
          }
        });
        return reports;
      }
    };
    
    console.log('🔧 沙箱调试器已就绪，使用 window.__SANDBOX_DEBUGGER__ 进行调试');
  }
}
```

## 性能优化

### 延迟初始化策略

```javascript
/**
 * 延迟初始化的沙箱管理器
 */
class LazyLoadingSandboxManager {
  constructor() {
    this.sandboxConfigs = new Map();
    this.sandboxInstances = new Map();
    this.initializationPromises = new Map();
  }

  /**
   * 注册沙箱配置（不立即创建）
   */
  register(appName, config) {
    this.sandboxConfigs.set(appName, config);
    console.log(`📋 注册沙箱配置: ${appName}`);
  }

  /**
   * 获取沙箱（延迟创建）
   */
  async getSandbox(appName) {
    // 如果已存在实例，直接返回
    if (this.sandboxInstances.has(appName)) {
      return this.sandboxInstances.get(appName);
    }

    // 如果正在初始化，等待完成
    if (this.initializationPromises.has(appName)) {
      return this.initializationPromises.get(appName);
    }

    // 开始初始化
    const initPromise = this.initializeSandbox(appName);
    this.initializationPromises.set(appName, initPromise);

    try {
      const sandbox = await initPromise;
      this.sandboxInstances.set(appName, sandbox);
      this.initializationPromises.delete(appName);
      return sandbox;
    } catch (error) {
      this.initializationPromises.delete(appName);
      throw error;
    }
  }

  /**
   * 初始化沙箱
   */
  async initializeSandbox(appName) {
    const config = this.sandboxConfigs.get(appName);
    if (!config) {
      throw new Error(`未找到应用 ${appName} 的沙箱配置`);
    }

    console.log(`🏗️ 开始初始化 ${appName} 沙箱`);
    const startTime = performance.now();

    const sandbox = new MicroFrontendSandbox(appName, config);
    
    const duration = performance.now() - startTime;
    console.log(`✅ ${appName} 沙箱初始化完成，耗时: ${duration.toFixed(2)}ms`);
    
    return sandbox;
  }

  /**
   * 预热沙箱
   */
  async preload(appName) {
    if (this.sandboxInstances.has(appName)) {
      return; // 已预热
    }

    console.log(`🔥 预热 ${appName} 沙箱`);
    await this.getSandbox(appName);
  }

  /**
   * 批量预热
   */
  async preloadAll(appNames) {
    const promises = appNames.map(appName => this.preload(appName));
    await Promise.all(promises);
    console.log(`🔥 批量预热完成: ${appNames.join(', ')}`);
  }

  /**
   * 清理未使用的沙箱
   */
  cleanup(activeApps) {
    const activeSet = new Set(activeApps);
    
    this.sandboxInstances.forEach(async (sandbox, appName) => {
      if (!activeSet.has(appName)) {
        console.log(`🧹 清理未使用的沙箱: ${appName}`);
        await sandbox.destroy();
        this.sandboxInstances.delete(appName);
      }
    });
  }
}
```

## 常见问题

### 1. 兼容性问题

```javascript
/**
 * 兼容性检查器
 */
class CompatibilityChecker {
  static check() {
    const results = {
      proxy: this.checkProxySupport(),
      shadowDOM: this.checkShadowDOMSupport(),
      mutationObserver: this.checkMutationObserverSupport(),
      performanceMemory: this.checkPerformanceMemorySupport(),
      weakMap: this.checkWeakMapSupport()
    };
    
    console.log('🔍 兼容性检查结果:', results);
    return results;
  }
  
  static checkProxySupport() {
    try {
      new Proxy({}, {});
      return { supported: true, version: 'native' };
    } catch (e) {
      return { 
        supported: false, 
        fallback: 'snapshot',
        message: 'Proxy not supported, fallback to snapshot sandbox'
      };
    }
  }
  
  static checkShadowDOMSupport() {
    const support = document.createElement('div').attachShadow ? 'native' : 'none';
    return {
      supported: support === 'native',
      version: support,
      fallback: support === 'none' ? 'css-namespace' : null
    };
  }
  
  static checkMutationObserverSupport() {
    return {
      supported: typeof MutationObserver !== 'undefined',
      fallback: 'polling'
    };
  }
  
  static checkPerformanceMemorySupport() {
    return {
      supported: !!(performance && performance.memory),
      message: performance.memory ? null : 'Memory monitoring unavailable'
    };
  }
  
  static checkWeakMapSupport() {
    return {
      supported: typeof WeakMap !== 'undefined',
      fallback: 'Map'
    };
  }
  
  static getRecommendedStrategy() {
    const compatibility = this.check();
    
    if (!compatibility.proxy.supported) {
      return 'snapshot';
    }
    
    if (compatibility.shadowDOM.supported) {
      return 'shadow';
    }
    
    return 'proxy';
  }
}
```

### 2. 错误处理和降级策略

```javascript
/**
 * 沙箱错误处理器
 */
class SandboxErrorHandler {
  constructor() {
    this.errorStrategies = new Map();
    this.setupDefaultStrategies();
  }

  /**
   * 设置默认错误处理策略
   */
  setupDefaultStrategies() {
    // Proxy 创建失败
    this.errorStrategies.set('proxy_creation_failed', {
      fallback: 'snapshot',
      action: (error, sandbox) => {
        console.warn('Proxy 沙箱创建失败，降级到快照沙箱', error);
        return new SnapshotSandbox(sandbox.appName);
      }
    });
    
    // Shadow DOM 创建失败
    this.errorStrategies.set('shadow_dom_failed', {
      fallback: 'css-namespace',
      action: (error, sandbox) => {
        console.warn('Shadow DOM 创建失败，降级到 CSS 命名空间', error);
        return new CSSNamespaceIsolation(sandbox.appName);
      }
    });
    
    // 内存监控失败
    this.errorStrategies.set('memory_monitoring_failed', {
      fallback: 'disable',
      action: (error, sandbox) => {
        console.warn('内存监控失败，禁用内存监控功能', error);
        sandbox.options.enableMemoryMonitoring = false;
        return null;
      }
    });
  }

  /**
   * 处理错误
   */
  handleError(errorType, error, sandbox) {
    const strategy = this.errorStrategies.get(errorType);
    
    if (!strategy) {
      console.error(`未知错误类型: ${errorType}`, error);
      throw error;
    }
    
    console.log(`🔄 执行错误处理策略: ${errorType} -> ${strategy.fallback}`);
    
    try {
      return strategy.action(error, sandbox);
    } catch (fallbackError) {
      console.error('错误处理策略执行失败', fallbackError);
      throw fallbackError;
    }
  }

  /**
   * 注册自定义错误策略
   */
  registerStrategy(errorType, strategy) {
    this.errorStrategies.set(errorType, strategy);
  }
}
```

## 总结

本文提供了一套完整的微前端沙箱隔离解决方案，包括：

### 🔧 **核心功能**
- **JavaScript 沙箱**：快照、代理、原生三种策略
- **CSS 样式隔离**：命名空间和 Shadow DOM 两种方案
- **资源生命周期管理**：完整的资源追踪和清理
- **内存泄漏检测**：实时监控和报告
- **错误处理和降级**：兼容性保障

### 🎯 **设计原则**
- **渐进增强**：从基础隔离到高级功能
- **策略可选**：根据需求选择合适的隔离策略
- **性能优先**：延迟加载和智能清理
- **开发友好**：丰富的调试工具和监控

### 🚀 **使用建议**
1. **开发阶段**：启用完整的监控和调试功能
2. **生产环境**：选择性能最优的策略组合
3. **兼容性要求高**：使用快照沙箱和 CSS 命名空间
4. **严格隔离需求**：使用原生沙箱或 Shadow DOM

这套方案可以满足不同场景下的微前端隔离需求，确保应用间的完全独立运行。
