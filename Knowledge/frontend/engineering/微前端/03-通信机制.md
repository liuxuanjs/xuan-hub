# 微前端通信机制

微前端应用间的通信是实现协调工作的关键。本文介绍各种通信方式的实现和最佳实践。

## 通信方式概览

| 通信方式 | 复杂度 | 性能 | 可靠性 | 适用场景 |
|----------|--------|------|--------|----------|
| Props 传递 | 低 | 高 | 高 | 主应用向子应用传递数据 |
| 事件总线 | 中 | 高 | 中 | 应用间松耦合通信 |
| 共享状态 | 高 | 中 | 高 | 复杂状态同步 |
| CustomEvent | 低 | 高 | 中 | 简单事件通知 |
| URL 参数 | 低 | 高 | 高 | 路由状态共享 |
| LocalStorage | 中 | 中 | 中 | 持久化数据共享 |

## 1. Props 传递

通过主应用向子应用传递 props 实现数据共享。

### qiankun 中的 Props 传递

```javascript
// 主应用
import { registerMicroApps } from 'qiankun';

registerMicroApps([
  {
    name: 'react-app',
    entry: '//localhost:3001',
    container: '#react-container',
    activeRule: '/react',
    props: {
      // 静态数据
      brand: 'qiankun',
      routerBase: '/react',
      
      // 动态数据
      user: getCurrentUser(),
      theme: getTheme(),
      
      // 回调函数
      onUserChange: (user) => {
        updateUser(user);
        // 通知其他子应用
        eventBus.emit('user:update', user);
      },
      
      onThemeChange: (theme) => {
        setTheme(theme);
        document.body.className = `theme-${theme}`;
      },
    },
  },
]);

// 动态更新 props
import { loadMicroApp } from 'qiankun';

const microApp = loadMicroApp({
  name: 'react-app',
  entry: '//localhost:3001',
  container: '#react-container',
  props: { initialData: 'some data' },
});

// 更新 props
microApp.update({ 
  user: newUser, 
  timestamp: Date.now() 
});
```

### 子应用接收 Props

```javascript
// React 子应用
export async function mount(props) {
  const { 
    user, 
    theme, 
    onUserChange, 
    onThemeChange,
    container 
  } = props;
  
  render(
    <App 
      user={user}
      theme={theme}
      onUserChange={onUserChange}
      onThemeChange={onThemeChange}
    />, 
    container?.querySelector('#root') || document.querySelector('#root')
  );
}

// Vue 子应用
export async function mount(props) {
  const { user, theme, container } = props;
  
  app = new Vue({
    data() {
      return {
        user,
        theme,
      };
    },
    render: h => h(App),
  }).$mount(container?.querySelector('#root') || '#root');
}
```

### Props 验证和类型安全

```typescript
// TypeScript 类型定义
interface MicroAppProps {
  user: User | null;
  theme: 'light' | 'dark';
  routerBase: string;
  onUserChange: (user: User) => void;
  onThemeChange: (theme: string) => void;
}

// Props 验证器
class PropsValidator {
  private schema: any;
  
  constructor(schema: any) {
    this.schema = schema;
  }
  
  validate(props: any): boolean {
    // 实现验证逻辑
    return this.validateObject(props, this.schema);
  }
  
  private validateObject(obj: any, schema: any): boolean {
    for (const key in schema) {
      if (schema[key].required && !(key in obj)) {
        console.error(`Missing required prop: ${key}`);
        return false;
      }
      
      if (key in obj && !this.validateType(obj[key], schema[key].type)) {
        console.error(`Invalid type for prop ${key}`);
        return false;
      }
    }
    return true;
  }
  
  private validateType(value: any, expectedType: string): boolean {
    switch (expectedType) {
      case 'string':
        return typeof value === 'string';
      case 'number':
        return typeof value === 'number';
      case 'function':
        return typeof value === 'function';
      case 'object':
        return typeof value === 'object' && value !== null;
      default:
        return true;
    }
  }
}

// 使用示例
const propsSchema = {
  user: { type: 'object', required: false },
  theme: { type: 'string', required: true },
  onUserChange: { type: 'function', required: true },
};

const validator = new PropsValidator(propsSchema);
```

## 2. 事件总线

基于发布订阅模式的应用间通信机制。

### 简单事件总线实现

```javascript
// 事件总线实现
class EventBus {
  constructor() {
    this.events = new Map();
    this.onceEvents = new Map();
  }
  
  // 订阅事件
  on(event, callback) {
    if (!this.events.has(event)) {
      this.events.set(event, []);
    }
    this.events.get(event).push(callback);
    
    // 返回取消订阅函数
    return () => this.off(event, callback);
  }
  
  // 一次性订阅
  once(event, callback) {
    if (!this.onceEvents.has(event)) {
      this.onceEvents.set(event, []);
    }
    this.onceEvents.get(event).push(callback);
  }
  
  // 取消订阅
  off(event, callback) {
    if (this.events.has(event)) {
      const callbacks = this.events.get(event);
      const index = callbacks.indexOf(callback);
      if (index > -1) {
        callbacks.splice(index, 1);
      }
    }
  }
  
  // 发布事件
  emit(event, data) {
    // 处理普通事件
    if (this.events.has(event)) {
      this.events.get(event).forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`Event handler error for ${event}:`, error);
        }
      });
    }
    
    // 处理一次性事件
    if (this.onceEvents.has(event)) {
      const callbacks = this.onceEvents.get(event);
      callbacks.forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`Once event handler error for ${event}:`, error);
        }
      });
      // 清除一次性事件
      this.onceEvents.delete(event);
    }
  }
  
  // 清除所有事件
  clear() {
    this.events.clear();
    this.onceEvents.clear();
  }
  
  // 获取事件统计
  getStats() {
    return {
      totalEvents: this.events.size,
      totalOnceEvents: this.onceEvents.size,
      eventNames: Array.from(this.events.keys()),
    };
  }
}

// 全局事件总线
window.microEventBus = new EventBus();
```

### 类型安全的事件总线

```typescript
// TypeScript 版本的事件总线
type EventMap = {
  'user:login': { userId: string; username: string };
  'user:logout': { userId: string };
  'theme:change': { theme: 'light' | 'dark' };
  'route:change': { from: string; to: string };
  'app:loaded': { appName: string };
  'app:error': { appName: string; error: Error };
};

class TypedEventBus<T extends Record<string, any>> {
  private events = new Map<keyof T, Array<(data: T[keyof T]) => void>>();
  
  on<K extends keyof T>(event: K, callback: (data: T[K]) => void) {
    if (!this.events.has(event)) {
      this.events.set(event, []);
    }
    this.events.get(event)!.push(callback as any);
    
    return () => this.off(event, callback);
  }
  
  off<K extends keyof T>(event: K, callback: (data: T[K]) => void) {
    const callbacks = this.events.get(event);
    if (callbacks) {
      const index = callbacks.indexOf(callback as any);
      if (index > -1) {
        callbacks.splice(index, 1);
      }
    }
  }
  
  emit<K extends keyof T>(event: K, data: T[K]) {
    const callbacks = this.events.get(event);
    if (callbacks) {
      callbacks.forEach(callback => callback(data));
    }
  }
}

// 使用示例
const eventBus = new TypedEventBus<EventMap>();

// 类型安全的事件监听
eventBus.on('user:login', (data) => {
  console.log(`用户 ${data.username} 登录了`);
});

// 类型安全的事件发送
eventBus.emit('user:login', { 
  userId: '123', 
  username: 'john' 
});
```

### 事件总线使用示例

```javascript
// 主应用
class MainApp {
  constructor() {
    this.setupEventListeners();
  }
  
  setupEventListeners() {
    // 监听用户登录
    window.microEventBus.on('user:login', (userData) => {
      this.updateUserInfo(userData);
      this.broadcastToAllApps('user:update', userData);
    });
    
    // 监听主题变更
    window.microEventBus.on('theme:change', (themeData) => {
      document.body.className = `theme-${themeData.theme}`;
      localStorage.setItem('theme', themeData.theme);
    });
    
    // 监听应用加载完成
    window.microEventBus.on('app:loaded', (appData) => {
      console.log(`应用 ${appData.appName} 加载完成`);
      this.updateAppStatus(appData.appName, 'loaded');
    });
  }
  
  broadcastToAllApps(event, data) {
    window.microEventBus.emit(event, data);
  }
  
  updateUserInfo(userData) {
    // 更新主应用的用户信息
    this.userInfo = userData;
    this.renderUserMenu();
  }
}

// 子应用 A - 用户管理
class UserManagementApp {
  constructor() {
    this.setupEventListeners();
  }
  
  setupEventListeners() {
    // 监听其他应用的用户更新
    window.microEventBus.on('user:update', (userData) => {
      this.syncUserData(userData);
    });
  }
  
  handleUserLogin(credentials) {
    const userData = this.authenticateUser(credentials);
    
    // 通知其他应用用户已登录
    window.microEventBus.emit('user:login', userData);
  }
  
  handleUserLogout() {
    const userId = this.currentUser.id;
    
    // 通知其他应用用户已登出
    window.microEventBus.emit('user:logout', { userId });
  }
}

// 子应用 B - 订单管理
class OrderManagementApp {
  constructor() {
    this.setupEventListeners();
  }
  
  setupEventListeners() {
    // 监听用户登录，加载用户订单
    window.microEventBus.on('user:login', (userData) => {
      this.loadUserOrders(userData.userId);
    });
    
    // 监听用户登出，清除订单数据
    window.microEventBus.on('user:logout', () => {
      this.clearOrderData();
    });
  }
  
  createOrder(orderData) {
    const order = this.saveOrder(orderData);
    
    // 通知其他应用有新订单
    window.microEventBus.emit('order:created', {
      orderId: order.id,
      userId: order.userId,
      amount: order.amount,
    });
  }
}
```

## 3. 共享状态管理

使用状态管理库实现跨应用的状态同步。

### 基于 Redux 的共享状态

```javascript
// 共享状态管理
import { createStore, combineReducers } from 'redux';

// 用户状态
const userReducer = (state = { current: null, preferences: {} }, action) => {
  switch (action.type) {
    case 'USER_LOGIN':
      return { ...state, current: action.payload };
    case 'USER_LOGOUT':
      return { ...state, current: null };
    case 'UPDATE_PREFERENCES':
      return { ...state, preferences: { ...state.preferences, ...action.payload } };
    default:
      return state;
  }
};

// 主题状态
const themeReducer = (state = { current: 'light', available: ['light', 'dark'] }, action) => {
  switch (action.type) {
    case 'SET_THEME':
      return { ...state, current: action.payload };
    default:
      return state;
  }
};

// 应用状态
const appReducer = (state = { loaded: [], active: null }, action) => {
  switch (action.type) {
    case 'APP_LOADED':
      return { ...state, loaded: [...state.loaded, action.payload] };
    case 'APP_ACTIVATED':
      return { ...state, active: action.payload };
    default:
      return state;
  }
};

// 创建全局 store
const rootReducer = combineReducers({
  user: userReducer,
  theme: themeReducer,
  app: appReducer,
});

const store = createStore(rootReducer);

// 暴露给子应用
window.sharedStore = store;

// Action Creators
window.sharedActions = {
  loginUser: (userData) => ({
    type: 'USER_LOGIN',
    payload: userData,
  }),
  
  logoutUser: () => ({
    type: 'USER_LOGOUT',
  }),
  
  setTheme: (theme) => ({
    type: 'SET_THEME',
    payload: theme,
  }),
  
  appLoaded: (appName) => ({
    type: 'APP_LOADED',
    payload: appName,
  }),
};
```

### React 中使用共享状态

```javascript
// React Hook for shared state
import { useEffect, useState } from 'react';

function useSharedState(selector) {
  const [state, setState] = useState(() => 
    selector(window.sharedStore.getState())
  );
  
  useEffect(() => {
    const unsubscribe = window.sharedStore.subscribe(() => {
      const newState = selector(window.sharedStore.getState());
      setState(newState);
    });
    
    return unsubscribe;
  }, [selector]);
  
  return [state, window.sharedStore.dispatch];
}

// 使用示例
function UserProfile() {
  const [user, dispatch] = useSharedState(state => state.user.current);
  const [theme] = useSharedState(state => state.theme.current);
  
  const handleLogin = (credentials) => {
    const userData = authenticateUser(credentials);
    dispatch(window.sharedActions.loginUser(userData));
  };
  
  const handleThemeChange = (newTheme) => {
    dispatch(window.sharedActions.setTheme(newTheme));
  };
  
  return (
    <div className={`user-profile theme-${theme}`}>
      {user ? (
        <div>
          <h3>欢迎, {user.name}</h3>
          <button onClick={() => dispatch(window.sharedActions.logoutUser())}>
            登出
          </button>
        </div>
      ) : (
        <LoginForm onLogin={handleLogin} />
      )}
      
      <ThemeSelector value={theme} onChange={handleThemeChange} />
    </div>
  );
}
```

### Vue 中使用共享状态

```javascript
// Vue 3 Composition API
import { ref, onMounted, onUnmounted } from 'vue';

function useSharedState(selector) {
  const state = ref(selector(window.sharedStore.getState()));
  let unsubscribe;
  
  onMounted(() => {
    unsubscribe = window.sharedStore.subscribe(() => {
      state.value = selector(window.sharedStore.getState());
    });
  });
  
  onUnmounted(() => {
    if (unsubscribe) {
      unsubscribe();
    }
  });
  
  return [state, window.sharedStore.dispatch];
}

// Vue 组件
export default {
  setup() {
    const [user, dispatch] = useSharedState(state => state.user.current);
    const [theme] = useSharedState(state => state.theme.current);
    
    const login = (credentials) => {
      const userData = authenticateUser(credentials);
      dispatch(window.sharedActions.loginUser(userData));
    };
    
    return {
      user,
      theme,
      login,
      logout: () => dispatch(window.sharedActions.logoutUser()),
    };
  },
};
```

## 4. CustomEvent

利用浏览器原生的 CustomEvent 实现通信。

### CustomEvent 基础实现

```javascript
// CustomEvent 通信管理器
class CustomEventCommunicator {
  constructor() {
    this.eventTarget = window;
    this.eventPrefix = 'micro-app:';
  }
  
  // 发送事件
  emit(type, data, options = {}) {
    const eventType = `${this.eventPrefix}${type}`;
    const event = new CustomEvent(eventType, {
      detail: data,
      bubbles: options.bubbles || false,
      cancelable: options.cancelable || false,
    });
    
    this.eventTarget.dispatchEvent(event);
  }
  
  // 监听事件
  on(type, callback) {
    const eventType = `${this.eventPrefix}${type}`;
    const handler = (event) => callback(event.detail);
    
    this.eventTarget.addEventListener(eventType, handler);
    
    // 返回取消监听函数
    return () => this.eventTarget.removeEventListener(eventType, handler);
  }
  
  // 一次性监听
  once(type, callback) {
    const eventType = `${this.eventPrefix}${type}`;
    const handler = (event) => {
      callback(event.detail);
      this.eventTarget.removeEventListener(eventType, handler);
    };
    
    this.eventTarget.addEventListener(eventType, handler);
  }
  
  // 取消监听
  off(type, callback) {
    const eventType = `${this.eventPrefix}${type}`;
    this.eventTarget.removeEventListener(eventType, callback);
  }
}

// 全局通信器
window.customEventBus = new CustomEventCommunicator();
```

### 事件命名规范

```javascript
// 事件命名规范
const EventTypes = {
  // 用户相关事件
  USER_LOGIN: 'user:login',
  USER_LOGOUT: 'user:logout',
  USER_UPDATE: 'user:update',
  
  // 应用生命周期事件
  APP_MOUNTED: 'app:mounted',
  APP_UNMOUNTED: 'app:unmounted',
  APP_ERROR: 'app:error',
  
  // 路由事件
  ROUTE_CHANGE: 'route:change',
  ROUTE_BEFORE_CHANGE: 'route:beforeChange',
  
  // 主题事件
  THEME_CHANGE: 'theme:change',
  
  // 数据事件
  DATA_REFRESH: 'data:refresh',
  DATA_UPDATE: 'data:update',
};

// 事件数据结构
const createEventData = (type, payload, meta = {}) => ({
  type,
  payload,
  meta: {
    timestamp: Date.now(),
    source: getCurrentAppName(),
    ...meta,
  },
});

// 使用示例
function emitUserLogin(userData) {
  const eventData = createEventData(EventTypes.USER_LOGIN, userData);
  window.customEventBus.emit(EventTypes.USER_LOGIN, eventData);
}

function listenUserLogin(callback) {
  return window.customEventBus.on(EventTypes.USER_LOGIN, (eventData) => {
    callback(eventData.payload, eventData.meta);
  });
}
```

### 事件拦截和中间件

```javascript
// 事件中间件系统
class EventMiddlewareSystem {
  constructor() {
    this.middlewares = [];
    this.originalEmit = window.customEventBus.emit;
    this.setupInterception();
  }
  
  // 设置拦截
  setupInterception() {
    window.customEventBus.emit = (type, data, options) => {
      // 执行中间件链
      const context = { type, data, options, stopped: false };
      
      for (const middleware of this.middlewares) {
        middleware(context);
        if (context.stopped) {
          return; // 停止事件传播
        }
      }
      
      // 执行原始 emit
      this.originalEmit.call(window.customEventBus, context.type, context.data, context.options);
    };
  }
  
  // 添加中间件
  use(middleware) {
    this.middlewares.push(middleware);
  }
  
  // 移除中间件
  remove(middleware) {
    const index = this.middlewares.indexOf(middleware);
    if (index > -1) {
      this.middlewares.splice(index, 1);
    }
  }
}

// 创建中间件系统
const eventMiddleware = new EventMiddlewareSystem();

// 日志中间件
eventMiddleware.use((context) => {
  console.log(`[Event] ${context.type}:`, context.data);
});

// 权限检查中间件
eventMiddleware.use((context) => {
  if (context.type.startsWith('admin:') && !isAdmin()) {
    console.warn('权限不足，事件被阻止');
    context.stopped = true;
  }
});

// 数据验证中间件
eventMiddleware.use((context) => {
  if (!validateEventData(context.type, context.data)) {
    console.error('事件数据验证失败');
    context.stopped = true;
  }
});
```

## 5. URL 参数通信

通过 URL 参数在应用间共享状态。

### URL 状态管理器

```javascript
// URL 状态管理器
class URLStateManager {
  constructor() {
    this.listeners = [];
    this.setupPopstateListener();
  }
  
  // 设置 URL 参数
  setState(key, value) {
    const url = new URL(window.location);
    
    if (value === null || value === undefined) {
      url.searchParams.delete(key);
    } else {
      url.searchParams.set(key, JSON.stringify(value));
    }
    
    window.history.pushState({}, '', url.toString());
    this.notifyListeners({ key, value });
  }
  
  // 获取 URL 参数
  getState(key) {
    const params = new URLSearchParams(window.location.search);
    const value = params.get(key);
    
    if (value === null) return null;
    
    try {
      return JSON.parse(value);
    } catch {
      return value;
    }
  }
  
  // 获取所有状态
  getAllState() {
    const params = new URLSearchParams(window.location.search);
    const state = {};
    
    for (const [key, value] of params.entries()) {
      try {
        state[key] = JSON.parse(value);
      } catch {
        state[key] = value;
      }
    }
    
    return state;
  }
  
  // 监听状态变化
  subscribe(callback) {
    this.listeners.push(callback);
    
    return () => {
      const index = this.listeners.indexOf(callback);
      if (index > -1) {
        this.listeners.splice(index, 1);
      }
    };
  }
  
  // 设置 popstate 监听
  setupPopstateListener() {
    window.addEventListener('popstate', () => {
      this.notifyListeners({ type: 'navigation' });
    });
  }
  
  // 通知监听器
  notifyListeners(change) {
    this.listeners.forEach(callback => {
      try {
        callback(change);
      } catch (error) {
        console.error('URL state listener error:', error);
      }
    });
  }
}

// 全局 URL 状态管理器
window.urlState = new URLStateManager();

// 使用示例
// 设置用户 ID
window.urlState.setState('userId', '123');

// 设置过滤条件
window.urlState.setState('filters', { status: 'active', type: 'premium' });

// 获取状态
const userId = window.urlState.getState('userId');
const filters = window.urlState.getState('filters');

// 监听变化
const unsubscribe = window.urlState.subscribe((change) => {
  console.log('URL 状态变化:', change);
});
```

## 6. LocalStorage 通信

通过 LocalStorage 实现持久化的跨应用数据共享。

### LocalStorage 状态管理器

```javascript
// LocalStorage 状态管理器
class LocalStorageStateManager {
  constructor(namespace = 'micro-app') {
    this.namespace = namespace;
    this.listeners = new Map();
    this.setupStorageListener();
  }
  
  // 生成带命名空间的 key
  getNamespacedKey(key) {
    return `${this.namespace}:${key}`;
  }
  
  // 设置状态
  setState(key, value) {
    const namespacedKey = this.getNamespacedKey(key);
    const serializedValue = JSON.stringify({
      value,
      timestamp: Date.now(),
    });
    
    localStorage.setItem(namespacedKey, serializedValue);
    this.notifyListeners(key, value);
  }
  
  // 获取状态
  getState(key) {
    const namespacedKey = this.getNamespacedKey(key);
    const item = localStorage.getItem(namespacedKey);
    
    if (!item) return null;
    
    try {
      const parsed = JSON.parse(item);
      return parsed.value;
    } catch {
      return null;
    }
  }
  
  // 移除状态
  removeState(key) {
    const namespacedKey = this.getNamespacedKey(key);
    localStorage.removeItem(namespacedKey);
    this.notifyListeners(key, null);
  }
  
  // 获取所有状态
  getAllState() {
    const state = {};
    const prefix = `${this.namespace}:`;
    
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith(prefix)) {
        const originalKey = key.substring(prefix.length);
        state[originalKey] = this.getState(originalKey);
      }
    }
    
    return state;
  }
  
  // 监听状态变化
  subscribe(key, callback) {
    if (!this.listeners.has(key)) {
      this.listeners.set(key, []);
    }
    this.listeners.get(key).push(callback);
    
    return () => {
      const callbacks = this.listeners.get(key);
      if (callbacks) {
        const index = callbacks.indexOf(callback);
        if (index > -1) {
          callbacks.splice(index, 1);
        }
      }
    };
  }
  
  // 设置 storage 事件监听
  setupStorageListener() {
    window.addEventListener('storage', (event) => {
      if (!event.key || !event.key.startsWith(`${this.namespace}:`)) {
        return;
      }
      
      const originalKey = event.key.substring(`${this.namespace}:`.length);
      let newValue = null;
      
      if (event.newValue) {
        try {
          const parsed = JSON.parse(event.newValue);
          newValue = parsed.value;
        } catch {
          newValue = event.newValue;
        }
      }
      
      this.notifyListeners(originalKey, newValue);
    });
  }
  
  // 通知监听器
  notifyListeners(key, value) {
    const callbacks = this.listeners.get(key);
    if (callbacks) {
      callbacks.forEach(callback => {
        try {
          callback(value);
        } catch (error) {
          console.error('LocalStorage listener error:', error);
        }
      });
    }
  }
}

// 全局 LocalStorage 状态管理器
window.localState = new LocalStorageStateManager();

// 使用示例
// 设置用户偏好
window.localState.setState('userPreferences', {
  theme: 'dark',
  language: 'zh-CN',
  sidebar: 'collapsed',
});

// 监听主题变化
window.localState.subscribe('userPreferences', (preferences) => {
  if (preferences?.theme) {
    document.body.className = `theme-${preferences.theme}`;
  }
});
```

## 通信最佳实践

### 1. 通信方式选择指南

```javascript
// 通信方式选择器
class CommunicationSelector {
  static choose(requirements) {
    const {
      dataSize,
      frequency,
      persistence,
      reliability,
      direction,
    } = requirements;
    
    // 大数据量 + 低频率 = Props 传递
    if (dataSize === 'large' && frequency === 'low') {
      return 'props';
    }
    
    // 小数据量 + 高频率 = 事件总线
    if (dataSize === 'small' && frequency === 'high') {
      return 'eventBus';
    }
    
    // 需要持久化 = LocalStorage
    if (persistence === 'required') {
      return 'localStorage';
    }
    
    // 路由相关 = URL 参数
    if (direction === 'shareable') {
      return 'urlParams';
    }
    
    // 复杂状态管理 = 共享状态
    if (reliability === 'high' && dataSize === 'medium') {
      return 'sharedState';
    }
    
    // 默认使用事件总线
    return 'eventBus';
  }
}

// 使用示例
const communicationWay = CommunicationSelector.choose({
  dataSize: 'small',
  frequency: 'high',
  persistence: 'optional',
  reliability: 'medium',
  direction: 'bidirectional',
});

console.log(`推荐使用: ${communicationWay}`);
```

### 2. 通信性能优化

```javascript
// 通信性能优化器
class CommunicationOptimizer {
  constructor() {
    this.eventQueue = [];
    this.isProcessing = false;
    this.batchDelay = 16; // 16ms，约 60fps
  }
  
  // 批量处理事件
  batchEmit(events) {
    this.eventQueue.push(...events);
    
    if (!this.isProcessing) {
      this.isProcessing = true;
      requestAnimationFrame(() => this.processBatch());
    }
  }
  
  // 处理批量事件
  processBatch() {
    const eventsToProcess = [...this.eventQueue];
    this.eventQueue = [];
    
    // 按类型分组
    const groupedEvents = this.groupEventsByType(eventsToProcess);
    
    // 处理每组事件
    Object.entries(groupedEvents).forEach(([type, events]) => {
      if (events.length === 1) {
        // 单个事件直接发送
        window.microEventBus.emit(type, events[0].data);
      } else {
        // 多个事件合并发送
        const mergedData = this.mergeEventData(events);
        window.microEventBus.emit(type, mergedData);
      }
    });
    
    this.isProcessing = false;
    
    // 如果还有待处理事件，继续处理
    if (this.eventQueue.length > 0) {
      requestAnimationFrame(() => this.processBatch());
    }
  }
  
  // 按类型分组事件
  groupEventsByType(events) {
    return events.reduce((groups, event) => {
      if (!groups[event.type]) {
        groups[event.type] = [];
      }
      groups[event.type].push(event);
      return groups;
    }, {});
  }
  
  // 合并事件数据
  mergeEventData(events) {
    if (events.length === 1) {
      return events[0].data;
    }
    
    // 根据事件类型决定合并策略
    const firstEvent = events[0];
    
    switch (firstEvent.type) {
      case 'data:update':
        // 数据更新事件合并最新值
        return events[events.length - 1].data;
      
      case 'user:activity':
        // 用户活动事件合并为数组
        return events.map(e => e.data);
      
      default:
        // 默认返回最新事件数据
        return events[events.length - 1].data;
    }
  }
}

// 全局性能优化器
window.communicationOptimizer = new CommunicationOptimizer();
```

### 3. 错误处理和重试机制

```javascript
// 通信错误处理器
class CommunicationErrorHandler {
  constructor() {
    this.retryAttempts = 3;
    this.retryDelay = 1000;
    this.failedEvents = [];
  }
  
  // 安全的事件发送
  async safeEmit(type, data, options = {}) {
    const { maxRetries = this.retryAttempts } = options;
    
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        await this.attemptEmit(type, data);
        return true;
      } catch (error) {
        console.warn(`事件发送失败 (尝试 ${attempt + 1}/${maxRetries + 1}):`, error);
        
        if (attempt < maxRetries) {
          await this.delay(this.retryDelay * Math.pow(2, attempt));
        } else {
          this.handleFailedEvent(type, data, error);
          return false;
        }
      }
    }
  }
  
  // 尝试发送事件
  async attemptEmit(type, data) {
    return new Promise((resolve, reject) => {
      try {
        window.microEventBus.emit(type, data);
        resolve();
      } catch (error) {
        reject(error);
      }
    });
  }
  
  // 处理失败的事件
  handleFailedEvent(type, data, error) {
    this.failedEvents.push({
      type,
      data,
      error: error.message,
      timestamp: Date.now(),
    });
    
    // 发送错误事件
    try {
      window.microEventBus.emit('communication:error', {
        eventType: type,
        error: error.message,
      });
    } catch {
      // 忽略错误事件发送失败
    }
  }
  
  // 重试失败的事件
  async retryFailedEvents() {
    const eventsToRetry = [...this.failedEvents];
    this.failedEvents = [];
    
    for (const event of eventsToRetry) {
      const success = await this.safeEmit(event.type, event.data);
      if (!success) {
        console.error(`事件 ${event.type} 重试仍然失败`);
      }
    }
  }
  
  // 延迟函数
  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  // 获取失败事件统计
  getFailureStats() {
    return {
      totalFailures: this.failedEvents.length,
      failuresByType: this.failedEvents.reduce((stats, event) => {
        stats[event.type] = (stats[event.type] || 0) + 1;
        return stats;
      }, {}),
    };
  }
}

// 全局错误处理器
window.communicationErrorHandler = new CommunicationErrorHandler();
```

## 总结

微前端通信机制的选择应该根据具体场景来决定：

- **Props 传递**：适合主应用向子应用传递初始数据
- **事件总线**：适合频繁的应用间通信
- **共享状态**：适合复杂的状态管理需求
- **CustomEvent**：适合简单的事件通知
- **URL 参数**：适合可分享的状态
- **LocalStorage**：适合需要持久化的数据

在实际项目中，通常会组合使用多种通信方式，形成完整的通信体系。

---

**下一步**：了解 [路由与状态管理](./04-路由与状态管理.md) 的详细实现
