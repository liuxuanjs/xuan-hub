# 微前端性能优化

微前端架构的性能优化是确保用户体验的关键环节。本文介绍各种性能优化策略和实现方案。

## 预加载策略

### qiankun 预加载

```javascript
// 预加载配置
start({
  prefetch: 'all', // 预加载所有子应用
  // 或者自定义预加载策略
  prefetch: (apps) => {
    const criticalApps = ['react-app', 'vue-app'];
    return apps.filter(app => criticalApps.includes(app.name));
  },
});

// 手动预加载
import { prefetchApps } from 'qiankun';

// 在合适的时机预加载
prefetchApps([
  { name: 'react-app', entry: '//localhost:3001' },
  { name: 'vue-app', entry: '//localhost:3002' },
]);
```

### single-spa 预加载

single-spa 本身没有内置预加载功能，下面是一个完整的预加载实现：

```javascript
import { registerApplication, start } from 'single-spa';

// 预加载管理器
const AppPreloader = {
  cache: {}, // 存储预加载的应用
  
  // 预加载应用
  async preload(name, loader) {
    // 如果已经预加载过，直接返回
    if (this.cache[name]) {
      return this.cache[name];
    }
    
    console.log(`🚀 开始预加载: ${name}`);
    try {
      this.cache[name] = await loader();
      console.log(`✅ 预加载完成: ${name}`);
      return this.cache[name];
    } catch (error) {
      console.error(`❌ 预加载失败: ${name}`, error);
      throw error;
    }
  },
  
  // 获取预加载的应用
  get(name) {
    return this.cache[name];
  },
  
  // 检查是否应该预加载（避免慢网络影响用户）
  shouldPreload() {
    if (navigator.connection) {
      const effectiveType = navigator.connection.effectiveType;
      // 2G 网络不预加载
      if (effectiveType === 'slow-2g' || effectiveType === '2g') {
        return false;
      }
    }
    return true;
  },
  
  // 自动预加载
  autoPreload() {
    if (!this.shouldPreload()) {
      console.log('🐌 网络较慢，跳过预加载');
      return;
    }
    
    // 页面加载完1秒后开始预加载，避免影响首屏性能
    setTimeout(() => {
      this.preload('react-app', () => System.import('react-app'));
      this.preload('vue-app', () => System.import('vue-app'));
    }, 1000);
  }
};

// 注册应用（支持预加载）
registerApplication({
  name: 'react-app',
  app: () => {
    // 先检查是否已预加载
    const cached = AppPreloader.get('react-app');
    if (cached) {
      console.log('📦 使用预加载的 React 应用');
      return Promise.resolve(cached);
    }
    // 没有预加载就正常加载
    return System.import('react-app');
  },
  activeWhen: '/react',
});

registerApplication({
  name: 'vue-app',
  app: () => {
    const cached = AppPreloader.get('vue-app');
    if (cached) {
      console.log('📦 使用预加载的 Vue 应用');
      return Promise.resolve(cached);
    }
    return System.import('vue-app');
  },
  activeWhen: '/vue',
});

// 启动 single-spa
start();

// 页面加载完成后开始预加载
window.addEventListener('load', () => {
  AppPreloader.autoPreload();
});

// 可选：鼠标悬停时也触发预加载
document.addEventListener('DOMContentLoaded', () => {
  // 给导航链接添加悬停预加载
  const reactLink = document.querySelector('a[href*="/react"]');
  const vueLink = document.querySelector('a[href*="/vue"]');
  
  if (reactLink) {
    reactLink.addEventListener('mouseenter', () => {
      AppPreloader.preload('react-app', () => System.import('react-app'));
    }, { once: true }); // 只触发一次
  }
  
  if (vueLink) {
    vueLink.addEventListener('mouseenter', () => {
      AppPreloader.preload('vue-app', () => System.import('vue-app'));
    }, { once: true });
  }
});
```

**使用示例（完整的 HTML 页面）：**

```html
<!DOCTYPE html>
<html>
<head>
  <title>Single-spa 预加载示例</title>
  <script src="https://cdn.jsdelivr.net/npm/systemjs@6/dist/system.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/single-spa@5/lib/system/single-spa.min.js"></script>
</head>
<body>
  <nav>
    <a href="/react">React 应用</a>
    <a href="/vue">Vue 应用</a>
  </nav>
  
  <div id="single-spa-application:react-app"></div>
  <div id="single-spa-application:vue-app"></div>

  <script type="systemjs-importmap">
    {
      "imports": {
        "react-app": "http://localhost:3001/main.js",
        "vue-app": "http://localhost:3002/main.js"
      }
    }
  </script>

  <script>
    // 这里放上面的 AppPreloader 和注册代码
  </script>
</body>
</html>
```

**核心原理很简单：**
1. **缓存机制**：用 `cache` 对象存储已加载的应用
2. **智能预加载**：页面加载完成后自动预加载，慢网络时跳过
3. **优先使用缓存**：注册应用时先检查缓存，有就直接用
4. **用户体验**：鼠标悬停时也会触发预加载，提前准备

这样实现的好处是应用切换会非常快，因为大部分情况下应用已经预加载好了！

## 资源共享

### Module Federation 共享依赖

```javascript
// Webpack Module Federation 共享依赖
module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'host',
      shared: {
        react: {
          singleton: true,
          requiredVersion: '^17.0.0',
        },
        'react-dom': {
          singleton: true,
          requiredVersion: '^17.0.0',
        },
        'antd': {
          singleton: true,
          requiredVersion: '^4.0.0',
        },
      },
    }),
  ],
};

// 外部依赖共享
window.sharedDependencies = {
  react: React,
  'react-dom': ReactDOM,
  antd: antd,
  moment: moment,
};

// 子应用使用共享依赖
const React = window.sharedDependencies?.react || require('react');
const ReactDOM = window.sharedDependencies?.['react-dom'] || require('react-dom');
```

## 缓存策略

```javascript
// 应用缓存管理
class AppCache {
  constructor() {
    this.cache = new Map();
    this.maxSize = 10;
  }
  
  // 缓存应用资源
  set(appName, resources) {
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    
    this.cache.set(appName, {
      resources,
      timestamp: Date.now(),
    });
  }
  
  // 获取缓存
  get(appName) {
    return this.cache.get(appName);
  }
  
  // 清理过期缓存
  cleanup(maxAge = 30 * 60 * 1000) { // 30分钟
    const now = Date.now();
    for (const [key, value] of this.cache.entries()) {
      if (now - value.timestamp > maxAge) {
        this.cache.delete(key);
      }
    }
  }
}

const appCache = new AppCache();
```

---

**完整性能优化内容请参考原文档**

**下一步**：了解 [监控与调试](./07-监控与调试.md) 的实现方案
