# 微前端路由与状态管理

在微前端架构中，路由管理和状态管理是两个关键的技术挑战。本文详细介绍如何在微前端场景下实现路由管理和跨应用状态同步。

## 路由管理

### 1. 主应用路由管理

```javascript
// React Router + qiankun
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';
import { registerMicroApps, start } from 'qiankun';

function App() {
  useEffect(() => {
    // 注册微应用
    registerMicroApps([
      {
        name: 'react-app',
        entry: '//localhost:3001',
        container: '#react-container',
        activeRule: '/react',
      },
      {
        name: 'vue-app',
        entry: '//localhost:3002',
        container: '#vue-container', 
        activeRule: '/vue',
      },
    ]);
    
    start();
  }, []);
  
  return (
    <BrowserRouter>
      <div className="app">
        <nav>
          <Link to="/react">React 应用</Link>
          <Link to="/vue">Vue 应用</Link>
        </nav>
        
        <Routes>
          <Route path="/react/*" element={<div id="react-container" />} />
          <Route path="/vue/*" element={<div id="vue-container" />} />
          <Route path="/" element={<Navigate to="/react" replace />} />
        </Routes>
      </div>
    </BrowserRouter>
  );
}
```

### 2. 子应用路由配置

```javascript
// React 子应用路由
import { BrowserRouter, Routes, Route } from 'react-router-dom';

function App() {
  // 获取路由前缀
  const basename = window.__POWERED_BY_QIANKUN__ ? '/react' : '/';
  
  return (
    <BrowserRouter basename={basename}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/users" element={<Users />} />
        <Route path="/settings" element={<Settings />} />
      </Routes>
    </BrowserRouter>
  );
}

// Vue 子应用路由
import { createRouter, createWebHistory } from 'vue-router';

const router = createRouter({
  history: createWebHistory(
    window.__POWERED_BY_QIANKUN__ ? '/vue' : '/'
  ),
  routes: [
    { path: '/', component: Home },
    { path: '/dashboard', component: Dashboard },
    { path: '/profile', component: Profile },
  ],
});
```

### 3. 路由通信

```javascript
// 路由状态管理
class RouteManager {
  constructor() {
    this.currentRoute = null;
    this.listeners = [];
  }
  
  // 监听路由变化
  listen(callback) {
    this.listeners.push(callback);
  }
  
  // 路由跳转
  push(path) {
    history.pushState(null, '', path);
    this.notify(path);
  }
  
  // 路由替换
  replace(path) {
    history.replaceState(null, '', path);
    this.notify(path);
  }
  
  // 通知路由变化
  notify(path) {
    this.currentRoute = path;
    this.listeners.forEach(callback => callback(path));
  }
}

// 全局路由管理器
window.routeManager = new RouteManager();

// 子应用监听路由变化
window.routeManager.listen((path) => {
  console.log('路由变化:', path);
});
```

## 状态管理

### 1. 全局状态管理

```javascript
// 使用 Zustand 创建全局状态
import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';

const useGlobalStore = create(
  subscribeWithSelector((set, get) => ({
    // 用户状态
    user: null,
    setUser: (user) => set({ user }),
    
    // 主题状态
    theme: 'light',
    setTheme: (theme) => set({ theme }),
    
    // 语言状态
    language: 'zh-CN',
    setLanguage: (language) => set({ language }),
    
    // 应用状态
    apps: {},
    setAppState: (appName, state) => 
      set((prev) => ({
        apps: { ...prev.apps, [appName]: state }
      })),
  }))
);

// 暴露给全局
window.globalStore = useGlobalStore;

// 子应用中使用
function MyComponent() {
  const { user, setUser } = window.globalStore();
  
  return (
    <div>
      <p>用户: {user?.name}</p>
      <button onClick={() => setUser({ name: 'John' })}>
        更新用户
      </button>
    </div>
  );
}
```

### 2. 状态同步机制

```javascript
// 状态同步管理器
class StateSync {
  constructor() {
    this.stores = new Map();
    this.subscribers = new Map();
  }
  
  // 注册应用状态
  register(appName, store) {
    this.stores.set(appName, store);
    
    // 监听状态变化
    store.subscribe((state) => {
      this.broadcast(appName, state);
    });
  }
  
  // 广播状态变化
  broadcast(sourceApp, state) {
    this.stores.forEach((store, appName) => {
      if (appName !== sourceApp) {
        // 通知其他应用状态变化
        store.updateExternalState?.(sourceApp, state);
      }
    });
  }
  
  // 获取所有应用状态
  getAllStates() {
    const states = {};
    this.stores.forEach((store, appName) => {
      states[appName] = store.getState();
    });
    return states;
  }
}

// 全局状态同步器
window.stateSync = new StateSync();
```

---

**完整内容请参考原文档中的路由管理和状态管理部分**

**下一步**：了解 [构建与部署](./05-构建与部署.md) 的详细方案
