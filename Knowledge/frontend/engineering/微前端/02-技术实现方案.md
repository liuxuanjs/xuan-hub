# 微前端技术实现方案

微前端有多种技术实现方案，每种方案都有其适用场景和优缺点。本文详细介绍主流的微前端实现方案。

## 方案概览

| 方案 | 技术复杂度 | 隔离程度 | 性能 | 生态支持 | 适用场景 |
|------|------------|----------|------|----------|----------|
| qiankun | 中 | 高 | 高 | 好 | React/Vue 项目 |
| single-spa | 中 | 中 | 高 | 好 | 多框架混合 |
| Module Federation | 高 | 低 | 高 | 一般 | Webpack 5 项目 |
| iframe | 低 | 最高 | 中 | 一般 | 快速集成 |

## 1. qiankun（推荐）

基于 single-spa 的微前端实现库，提供了更完善的沙箱隔离和样式隔离。

### 特点

- ✅ 开箱即用的沙箱隔离
- ✅ 样式隔离方案完善
- ✅ 生命周期管理完整
- ✅ 中文文档友好
- ❌ 主要支持 React/Vue
- ❌ 学习曲线相对陡峭

### 主应用配置

```javascript
// main.js
import { registerMicroApps, start, setDefaultMountApp } from 'qiankun';

// 注册微应用
registerMicroApps(
  [
    {
      name: 'reactApp',
      entry: '//localhost:3001',
      container: '#react-app',
      activeRule: '/react',
      props: {
        // 传递给子应用的数据
        brand: 'qiankun',
        routerBase: '/react',
      },
    },
    {
      name: 'vueApp',
      entry: '//localhost:3002', 
      container: '#vue-app',
      activeRule: '/vue',
    },
  ],
  {
    // 生命周期钩子
    beforeLoad: (app) => {
      console.log('before load', app);
    },
    beforeMount: (app) => {
      console.log('before mount', app);
    },
    afterMount: (app) => {
      console.log('after mount', app);
    },
    beforeUnmount: (app) => {
      console.log('before unmount', app);
    },
    afterUnmount: (app) => {
      console.log('after unmount', app);
    },
  }
);

// 设置默认子应用
setDefaultMountApp('/react');

// 启动
start({
  prefetch: 'all', // 预加载策略
  sandbox: {
    strictStyleIsolation: true, // 严格样式隔离
    experimentalStyleIsolation: true, // 实验性样式隔离
  },
  singular: false, // 是否为单实例场景
});
```

### 子应用改造

```javascript
// React 子应用 src/index.js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';

function render(props) {
  const { container } = props;
  ReactDOM.render(
    <App />, 
    container ? container.querySelector('#root') : document.querySelector('#root')
  );
}

// 独立运行环境
if (!window.__POWERED_BY_QIANKUN__) {
  render({});
}

// 微前端环境生命周期
export async function bootstrap() {
  console.log('[react16] react app bootstraped');
}

export async function mount(props) {
  console.log('[react16] props from main framework', props);
  render(props);
}

export async function unmount(props) {
  const { container } = props;
  ReactDOM.unmountComponentAtNode(
    container ? container.querySelector('#root') : document.querySelector('#root')
  );
}
```

### webpack 配置

```javascript
// webpack.config.js (子应用)
const { name } = require('./package');

module.exports = {
  output: {
    library: `${name}-[name]`,
    libraryTarget: 'umd',
    jsonpFunction: `webpackJsonp_${name}`,
  },
  devServer: {
    headers: {
      'Access-Control-Allow-Origin': '*',
    },
  },
};
```

### 高级配置

```javascript
// 动态注册应用
import { loadMicroApp } from 'qiankun';

// 手动加载微应用
const microApp = loadMicroApp({
  name: 'manual-app',
  entry: '//localhost:3003',
  container: '#manual-container',
});

// 卸载微应用
microApp.unmount();

// 获取微应用状态
console.log(microApp.getStatus()); // LOADING | MOUNTING | MOUNTED | UNMOUNTING

// 更新微应用
microApp.update({ customProps: 'new data' });
```

## 2. single-spa

微前端的基础框架，提供了应用注册、路由管理等核心功能。

### 特点

- ✅ 框架无关，支持所有前端技术栈
- ✅ 社区成熟，生态丰富
- ✅ 灵活性高，可定制性强
- ❌ 需要更多手动配置
- ❌ 样式隔离需要自己实现

### 基础配置

```javascript
// 主应用
import { registerApplication, start } from 'single-spa';

// 注册应用
registerApplication({
  name: 'react-app',
  app: () => System.import('react-app'),
  activeWhen: '/react',
  customProps: {
    domElement: document.getElementById('react-app'),
    authToken: 'Bearer token',
  },
});

registerApplication({
  name: 'vue-app',
  app: () => System.import('vue-app'),
  activeWhen: '/vue',
  customProps: {
    domElement: document.getElementById('vue-app'),
  },
});

// 启动
start({
  urlRerouteOnly: true, // 只在 URL 变化时重新路由
});
```

### 子应用实现

```javascript
// React 子应用
import React from 'react';
import ReactDOM from 'react-dom';
import singleSpaReact from 'single-spa-react';
import App from './App';

const lifecycles = singleSpaReact({
  React,
  ReactDOM,
  rootComponent: App,
  domElementGetter: () => document.getElementById('react-app'),
});

export const { bootstrap, mount, unmount } = lifecycles;
```

```javascript
// Vue 子应用
import Vue from 'vue';
import singleSpaVue from 'single-spa-vue';
import App from './App.vue';

const vueLifecycles = singleSpaVue({
  Vue,
  appOptions: {
    render: (h) => h(App),
    el: '#vue-app',
  },
});

export const { bootstrap, mount, unmount } = vueLifecycles;
```

### 路由集成

```javascript
// 使用 single-spa 路由助手
import { navigateToUrl } from 'single-spa';

// 编程式导航
function navigateToReactApp() {
  navigateToUrl('/react/dashboard');
}

// 声明式导航
function NavLink({ to, children }) {
  return (
    <a href={to} onClick={(e) => {
      e.preventDefault();
      navigateToUrl(to);
    }}>
      {children}
    </a>
  );
}
```

## 3. Module Federation (Webpack 5)

Webpack 5 原生支持的微前端解决方案，通过模块联邦实现应用间的模块共享。

### 特点

- ✅ Webpack 原生支持
- ✅ 构建时优化
- ✅ 模块级别的共享
- ✅ TypeScript 支持良好
- ❌ 只支持 Webpack 5+
- ❌ 运行时依赖管理复杂

### 主应用配置

```javascript
// 主应用 webpack.config.js
const ModuleFederationPlugin = require('@module-federation/webpack');

module.exports = {
  mode: 'development',
  devServer: {
    port: 3000,
  },
  plugins: [
    new ModuleFederationPlugin({
      name: 'host',
      remotes: {
        mf_react: 'mf_react@http://localhost:3001/remoteEntry.js',
        mf_vue: 'mf_vue@http://localhost:3002/remoteEntry.js',
      },
      shared: {
        react: { singleton: true },
        'react-dom': { singleton: true },
      },
    }),
  ],
};
```

### 子应用配置

```javascript
// React 子应用 webpack.config.js
module.exports = {
  mode: 'development',
  devServer: {
    port: 3001,
  },
  plugins: [
    new ModuleFederationPlugin({
      name: 'mf_react',
      filename: 'remoteEntry.js',
      exposes: {
        './App': './src/App',
        './Button': './src/components/Button',
        './UserService': './src/services/UserService',
      },
      shared: {
        react: { singleton: true },
        'react-dom': { singleton: true },
      },
    }),
  ],
};
```

### 使用远程模块

```javascript
// 主应用中使用子应用组件
import React, { Suspense } from 'react';

const RemoteButton = React.lazy(() => import('mf_react/Button'));
const RemoteApp = React.lazy(() => import('mf_react/App'));
const UserService = React.lazy(() => import('mf_react/UserService'));

function App() {
  return (
    <div>
      <h1>主应用</h1>
      
      {/* 使用远程组件 */}
      <Suspense fallback={<div>Loading Button...</div>}>
        <RemoteButton />
      </Suspense>
      
      {/* 使用远程应用 */}
      <Suspense fallback={<div>Loading Remote App...</div>}>
        <RemoteApp />
      </Suspense>
    </div>
  );
}
```

### 动态远程加载

```javascript
// 动态加载远程模块
async function loadRemoteModule(scope, module) {
  // 初始化共享作用域
  await __webpack_init_sharing__('default');
  
  // 获取远程容器
  const container = window[scope];
  await container.init(__webpack_share_scopes__.default);
  
  // 获取模块工厂
  const factory = await container.get(module);
  const Module = factory();
  
  return Module;
}

// 使用示例
const RemoteComponent = await loadRemoteModule('mf_react', './Button');
```

### 共享依赖策略

```javascript
// 复杂的共享配置
module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      shared: {
        // 单例模式，所有应用共享同一实例
        react: {
          singleton: true,
          requiredVersion: '^18.0.0',
          eager: true,
        },
        
        // 版本兼容模式
        lodash: {
          requiredVersion: '^4.17.0',
          singleton: false,
        },
        
        // 自定义加载
        'shared-utils': {
          import: './src/shared-utils',
          shareKey: 'utils',
          shareScope: 'default',
        },
      },
    }),
  ],
};
```

## 4. iframe 方案

最简单但限制较多的微前端实现方式。

### 特点

- ✅ 完全隔离，天然沙箱
- ✅ 实现简单，无需改造
- ✅ 支持任意技术栈
- ❌ 性能问题，资源重复加载
- ❌ 用户体验差，页面割裂感
- ❌ 通信复杂，状态管理困难

### 基础实现

```javascript
// iframe 微前端管理器
class IframeMicroApp {
  constructor() {
    this.apps = new Map();
    this.currentApp = null;
  }
  
  // 注册应用
  register(name, url, container) {
    this.apps.set(name, { url, container });
  }
  
  // 加载应用
  load(name) {
    const app = this.apps.get(name);
    if (!app) return;
    
    // 隐藏当前应用
    if (this.currentApp) {
      this.currentApp.style.display = 'none';
    }
    
    // 创建或显示 iframe
    let iframe = document.querySelector(`iframe[data-app="${name}"]`);
    if (!iframe) {
      iframe = this.createIframe(name, app);
    } else {
      iframe.style.display = 'block';
    }
    
    this.currentApp = iframe;
  }
  
  // 创建 iframe
  createIframe(name, app) {
    const iframe = document.createElement('iframe');
    iframe.src = app.url;
    iframe.setAttribute('data-app', name);
    iframe.style.width = '100%';
    iframe.style.height = '100%';
    iframe.style.border = 'none';
    iframe.style.display = 'block';
    
    // 监听加载事件
    iframe.onload = () => {
      console.log(`应用 ${name} 加载完成`);
      this.postMessage(name, { type: 'APP_READY' });
    };
    
    app.container.appendChild(iframe);
    return iframe;
  }
  
  // 通信
  postMessage(appName, data) {
    const iframe = document.querySelector(`iframe[data-app="${appName}"]`);
    if (iframe) {
      iframe.contentWindow.postMessage(data, '*');
    }
  }
  
  // 卸载应用
  unload(name) {
    const iframe = document.querySelector(`iframe[data-app="${name}"]`);
    if (iframe) {
      iframe.remove();
    }
  }
}

// 使用示例
const microApp = new IframeMicroApp();
microApp.register('react-app', 'http://localhost:3001', document.getElementById('app-container'));
microApp.load('react-app');
```

### 通信机制

```javascript
// 主应用 - iframe 通信
class IframeCommunicator {
  constructor() {
    this.messageHandlers = new Map();
    this.setupMessageListener();
  }
  
  // 设置消息监听
  setupMessageListener() {
    window.addEventListener('message', (event) => {
      const { source, data } = event;
      const { type, payload } = data || {};
      
      if (this.messageHandlers.has(type)) {
        this.messageHandlers.get(type)(payload, source);
      }
    });
  }
  
  // 注册消息处理器
  on(type, handler) {
    this.messageHandlers.set(type, handler);
  }
  
  // 发送消息给子应用
  send(iframe, type, payload) {
    iframe.contentWindow.postMessage({ type, payload }, '*');
  }
  
  // 广播消息给所有子应用
  broadcast(type, payload) {
    const iframes = document.querySelectorAll('iframe[data-app]');
    iframes.forEach(iframe => {
      this.send(iframe, type, payload);
    });
  }
}

// 子应用中的通信
class ChildAppCommunicator {
  constructor() {
    this.messageHandlers = new Map();
    this.setupMessageListener();
  }
  
  setupMessageListener() {
    window.addEventListener('message', (event) => {
      const { data } = event;
      const { type, payload } = data || {};
      
      if (this.messageHandlers.has(type)) {
        this.messageHandlers.get(type)(payload);
      }
    });
  }
  
  // 发送消息给主应用
  sendToParent(type, payload) {
    window.parent.postMessage({ type, payload }, '*');
  }
  
  // 注册消息处理器
  on(type, handler) {
    this.messageHandlers.set(type, handler);
  }
}
```

### iframe 优化

```javascript
// iframe 性能优化
class OptimizedIframe {
  constructor(config) {
    this.config = config;
    this.iframe = null;
    this.isLoaded = false;
  }
  
  // 预加载
  preload() {
    this.iframe = document.createElement('iframe');
    this.iframe.src = this.config.url;
    this.iframe.style.display = 'none';
    this.iframe.onload = () => {
      this.isLoaded = true;
    };
    document.body.appendChild(this.iframe);
  }
  
  // 显示
  show(container) {
    if (!this.iframe) {
      this.create(container);
    } else {
      container.appendChild(this.iframe);
      this.iframe.style.display = 'block';
    }
  }
  
  // 隐藏
  hide() {
    if (this.iframe) {
      this.iframe.style.display = 'none';
    }
  }
  
  // 销毁
  destroy() {
    if (this.iframe) {
      this.iframe.remove();
      this.iframe = null;
      this.isLoaded = false;
    }
  }
  
  // 创建 iframe
  create(container) {
    this.iframe = document.createElement('iframe');
    this.iframe.src = this.config.url;
    this.iframe.style.width = '100%';
    this.iframe.style.height = '100%';
    this.iframe.style.border = 'none';
    
    // 安全设置
    this.iframe.sandbox = 'allow-same-origin allow-scripts allow-forms';
    
    container.appendChild(this.iframe);
  }
}
```

## 5. 自定义方案

### Web Components

```javascript
// 基于 Web Components 的微前端
class MicroAppElement extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }
  
  connectedCallback() {
    const appName = this.getAttribute('app');
    const appUrl = this.getAttribute('src');
    
    this.loadApp(appName, appUrl);
  }
  
  async loadApp(name, url) {
    try {
      // 加载应用资源
      const response = await fetch(url);
      const html = await response.text();
      
      // 解析并注入资源
      this.shadowRoot.innerHTML = html;
      
      // 加载 JavaScript
      const scripts = this.shadowRoot.querySelectorAll('script');
      scripts.forEach(script => {
        const newScript = document.createElement('script');
        newScript.textContent = script.textContent;
        this.shadowRoot.appendChild(newScript);
      });
      
    } catch (error) {
      console.error(`加载应用 ${name} 失败:`, error);
    }
  }
}

// 注册自定义元素
customElements.define('micro-app', MicroAppElement);
```

### SystemJS

```javascript
// 基于 SystemJS 的动态加载
class SystemJSMicroApp {
  constructor() {
    this.apps = new Map();
  }
  
  // 注册应用
  register(name, url) {
    this.apps.set(name, { url, loaded: false, instance: null });
  }
  
  // 加载应用
  async load(name) {
    const app = this.apps.get(name);
    if (!app) throw new Error(`应用 ${name} 未注册`);
    
    if (!app.loaded) {
      // 使用 SystemJS 动态导入
      const module = await System.import(app.url);
      app.instance = module;
      app.loaded = true;
    }
    
    return app.instance;
  }
  
  // 挂载应用
  async mount(name, container, props = {}) {
    const app = await this.load(name);
    
    if (app.mount) {
      await app.mount({ container, ...props });
    }
  }
  
  // 卸载应用
  async unmount(name, props = {}) {
    const app = this.apps.get(name);
    
    if (app?.instance?.unmount) {
      await app.instance.unmount(props);
    }
  }
}
```

## 方案选择指南

### 决策树

```javascript
function chooseMicroFrontendSolution(requirements) {
  const {
    teamSize,
    techStack,
    legacySystem,
    performanceRequirement,
    developmentSpeed,
    isolationLevel,
  } = requirements;
  
  // 快速原型或演示
  if (developmentSpeed === 'fast' && isolationLevel === 'high') {
    return 'iframe';
  }
  
  // Webpack 5 项目
  if (techStack.includes('webpack5') && performanceRequirement === 'high') {
    return 'module-federation';
  }
  
  // React/Vue 主导的项目
  if (techStack.includes('react') || techStack.includes('vue')) {
    return 'qiankun';
  }
  
  // 多技术栈混合
  if (techStack.length > 2) {
    return 'single-spa';
  }
  
  // 默认推荐
  return 'qiankun';
}

// 使用示例
const solution = chooseMicroFrontendSolution({
  teamSize: 'large',
  techStack: ['react', 'vue', 'angular'],
  legacySystem: true,
  performanceRequirement: 'high',
  developmentSpeed: 'normal',
  isolationLevel: 'medium',
});

console.log(`推荐方案: ${solution}`);
```

### 评估标准

```javascript
// 方案评估矩阵
const evaluationMatrix = {
  qiankun: {
    learningCurve: 7,    // 学习曲线 (1-10)
    performance: 8,      // 性能表现
    isolation: 9,        // 隔离程度
    ecosystem: 8,        // 生态支持
    flexibility: 7,      // 灵活性
    maintenance: 8,      // 可维护性
  },
  singleSpa: {
    learningCurve: 8,
    performance: 8,
    isolation: 7,
    ecosystem: 9,
    flexibility: 9,
    maintenance: 7,
  },
  moduleFederation: {
    learningCurve: 9,
    performance: 9,
    isolation: 6,
    ecosystem: 6,
    flexibility: 8,
    maintenance: 7,
  },
  iframe: {
    learningCurve: 3,
    performance: 5,
    isolation: 10,
    ecosystem: 5,
    flexibility: 4,
    maintenance: 6,
  },
};

// 计算综合评分
function calculateScore(solution, weights) {
  const scores = evaluationMatrix[solution];
  let totalScore = 0;
  let totalWeight = 0;
  
  Object.entries(weights).forEach(([criterion, weight]) => {
    totalScore += scores[criterion] * weight;
    totalWeight += weight;
  });
  
  return totalScore / totalWeight;
}

// 示例：性能和隔离更重要
const weights = {
  learningCurve: 1,
  performance: 3,
  isolation: 3,
  ecosystem: 2,
  flexibility: 2,
  maintenance: 2,
};

Object.keys(evaluationMatrix).forEach(solution => {
  const score = calculateScore(solution, weights);
  console.log(`${solution}: ${score.toFixed(2)}`);
});
```

## 总结

选择微前端技术方案时，需要综合考虑：

1. **团队技术栈**：选择团队熟悉的技术
2. **项目规模**：大型项目选择功能完善的方案
3. **性能要求**：高性能要求选择构建时优化方案
4. **隔离需求**：高隔离需求选择沙箱方案
5. **迁移成本**：考虑现有系统的改造成本

**推荐策略**：
- **新项目**：qiankun 或 Module Federation
- **混合技术栈**：single-spa
- **快速集成**：iframe
- **高性能要求**：Module Federation

---

**下一步**：了解 [通信机制](./03-通信机制.md) 的实现方案
