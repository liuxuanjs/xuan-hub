## 概述
CSS容器查询（Container Queries）允许根据父容器的尺寸而非视口尺寸来应用样式，实现真正的组件级响应式设计。

## 基本概念

### 什么是容器查询
```css
/* 传统媒体查询：基于视口 */
@media (max-width: 768px) {
    .card { font-size: 14px; }
}

/* 容器查询：基于容器 */
@container (max-width: 400px) {
    .card { font-size: 14px; }
}
```

### 容器上下文
```css
.container {
    container-type: inline-size;    /* 创建容器上下文 */
    /* 或者 */
    contain: layout inline-size;    /* 等价写法 */
}
```

## 基本语法

### 定义容器
```css
.card-container {
    container-type: inline-size;    /* 基于宽度 */
    /* container-type: size;       基于宽度和高度 */
    /* container-type: normal;     默认值，不是容器 */
}
```

### 容器查询规则
```css
.card-container {
    container-type: inline-size;
}

@container (min-width: 400px) {
    .card {
        display: flex;
        flex-direction: row;
    }
    
    .card-image {
        width: 200px;
    }
}

@container (max-width: 399px) {
    .card {
        display: block;
    }
    
    .card-image {
        width: 100%;
    }
}
```

## 实际应用场景

### 1. 响应式卡片组件
```html
<div class="card-wrapper">
    <div class="card">
        <img src="image.jpg" class="card-image">
        <div class="card-content">
            <h3 class="card-title">标题</h3>
            <p class="card-text">内容描述</p>
        </div>
    </div>
</div>
```

```css
.card-wrapper {
    container-type: inline-size;
    width: 100%;
}

/* 小容器：垂直布局 */
@container (max-width: 350px) {
    .card {
        display: flex;
        flex-direction: column;
    }
    
    .card-image {
        width: 100%;
        height: 200px;
        object-fit: cover;
    }
    
    .card-title {
        font-size: 18px;
    }
}

/* 大容器：水平布局 */
@container (min-width: 351px) {
    .card {
        display: flex;
        flex-direction: row;
        align-items: center;
    }
    
    .card-image {
        width: 150px;
        height: 150px;
        flex-shrink: 0;
        margin-right: 20px;
    }
    
    .card-title {
        font-size: 22px;
    }
}
```

### 2. 侧边栏适配
```css
.sidebar {
    container-type: inline-size;
    width: 300px;
    transition: width 0.3s ease;
}

.sidebar.collapsed {
    width: 80px;
}

/* 宽侧边栏：显示文字 */
@container (min-width: 200px) {
    .nav-item {
        display: flex;
        align-items: center;
        padding: 12px 16px;
    }
    
    .nav-icon {
        margin-right: 12px;
    }
    
    .nav-text {
        display: block;
    }
}

/* 窄侧边栏：只显示图标 */
@container (max-width: 199px) {
    .nav-item {
        display: flex;
        justify-content: center;
        padding: 12px;
    }
    
    .nav-text {
        display: none;
    }
}
```

### 3. 网格项目适配
```css
.grid-container {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 20px;
}

.grid-item {
    container-type: inline-size;
    background: white;
    border-radius: 8px;
    padding: 20px;
}

/* 窄网格项：简单布局 */
@container (max-width: 300px) {
    .item-content {
        text-align: center;
    }
    
    .item-image {
        width: 60px;
        height: 60px;
        margin: 0 auto 16px;
    }
    
    .item-title {
        font-size: 16px;
    }
}

/* 宽网格项：复杂布局 */
@container (min-width: 301px) {
    .item-content {
        display: flex;
        align-items: flex-start;
        text-align: left;
    }
    
    .item-image {
        width: 80px;
        height: 80px;
        margin-right: 16px;
        flex-shrink: 0;
    }
    
    .item-title {
        font-size: 20px;
    }
}
```

## 命名容器

### 容器命名
```css
.main-content {
    container-type: inline-size;
    container-name: main;       /* 给容器命名 */
}

.sidebar-content {
    container-type: inline-size;
    container-name: sidebar;
}
```

### 针对特定容器查询
```css
/* 只对名为main的容器生效 */
@container main (min-width: 600px) {
    .content-article {
        columns: 2;
        column-gap: 40px;
    }
}

/* 只对名为sidebar的容器生效 */
@container sidebar (max-width: 200px) {
    .widget {
        display: none;
    }
}
```

## 容器查询单位

### 新的单位
```css
.container {
    container-type: size;
}

@container (min-width: 400px) {
    .element {
        font-size: 4cqw;       /* 4% 容器宽度 */
        padding: 2cqh;         /* 2% 容器高度 */
        margin: 1cqi;          /* 1% 容器内联尺寸 */
        border: 0.5cqb solid;  /* 0.5% 容器块尺寸 */
    }
}
```

### 单位说明
- `cqw` - 容器宽度的1%
- `cqh` - 容器高度的1%  
- `cqi` - 容器内联尺寸的1%
- `cqb` - 容器块尺寸的1%
- `cqmin` - cqi和cqb中较小值的1%
- `cqmax` - cqi和cqb中较大值的1%

## 高级应用

### 1. 多级容器查询
```css
.outer-container {
    container-type: inline-size;
    container-name: outer;
}

.inner-container {
    container-type: inline-size;
    container-name: inner;
}

/* 基于外层容器 */
@container outer (min-width: 800px) {
    .layout {
        display: grid;
        grid-template-columns: 1fr 1fr;
    }
}

/* 基于内层容器 */
@container inner (max-width: 300px) {
    .component {
        font-size: 14px;
    }
}
```

### 2. 条件组合
```css
@container (min-width: 400px) and (max-width: 800px) {
    .element {
        background: lightblue;
    }
}

@container (min-width: 300px) or (min-height: 200px) {
    .element {
        padding: 20px;
    }
}
```

### 3. 动态容器尺寸
```css
.resizable-container {
    container-type: inline-size;
    width: 50%;
    resize: horizontal;      /* 允许用户调整大小 */
    overflow: auto;
    border: 2px solid #ccc;
}

@container (max-width: 250px) {
    .content { font-size: 12px; }
}

@container (min-width: 500px) {
    .content { font-size: 18px; }
}
```

## 实用技巧

### 1. 渐进增强
```css
/* 降级方案 */
.card {
    display: block;
}

/* 支持容器查询的浏览器 */
@supports (container-type: inline-size) {
    .card-container {
        container-type: inline-size;
    }
    
    @container (min-width: 400px) {
        .card {
            display: flex;
        }
    }
}
```

### 2. 调试容器
```css
.debug-container {
    container-type: inline-size;
    outline: 2px dashed red;
    position: relative;
}

.debug-container::before {
    content: 'Container: ' attr(data-width);
    position: absolute;
    top: -20px;
    left: 0;
    background: red;
    color: white;
    padding: 2px 6px;
    font-size: 12px;
}
```

## 浏览器兼容性

### 支持情况
- Chrome 105+
- Firefox 110+
- Safari 16+
- 暂不支持IE/Edge Legacy

### 兼容性检测
```css
@supports (container-type: inline-size) {
    /* 支持容器查询的样式 */
    .modern-layout {
        container-type: inline-size;
    }
}

@supports not (container-type: inline-size) {
    /* 降级样式 */
    .fallback-layout {
        /* 使用传统响应式方案 */
    }
}
```

## JavaScript交互

### 监听容器尺寸变化
```javascript
// 使用ResizeObserver监听容器
const observer = new ResizeObserver(entries => {
    entries.forEach(entry => {
        const width = entry.contentRect.width;
        entry.target.dataset.width = `${width}px`;
    });
});

observer.observe(document.querySelector('.container'));
```

## 总结

CSS容器查询的核心优势：

1. **组件级响应式**：基于容器而非视口
2. **真正的模块化**：组件可以独立适配
3. **更细粒度控制**：精确的尺寸响应
4. **命名容器**：支持多级容器管理
5. **新单位系统**：基于容器的相对单位
6. **未来趋势**：现代响应式设计方向

容器查询为组件化开发提供了强大的响应式能力，是CSS布局的重要发展方向。