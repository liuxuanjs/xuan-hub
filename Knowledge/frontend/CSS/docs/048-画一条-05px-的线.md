## 概述

在高DPR（设备像素比）的屏幕上，实现真正的0.5px细线是一个常见需求。由于浏览器对小于1px的边框处理不一致，需要使用特殊技巧来实现精确的细线效果。

## 实现方案

### 1. transform scale方案（推荐）

```css
.hairline {
    position: relative;
}

.hairline::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 200%;
    height: 1px;
    background: #e5e5e5;
    transform: scale(0.5);
    transform-origin: 0 0;
}
```

**原理：**
- 创建1px的线条，然后缩放到0.5倍
- 使用伪元素避免影响原有布局
- `transform-origin`确保缩放基点正确

### 2. 四边细线实现

```css
.hairline-border {
    position: relative;
}

.hairline-border::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 200%;
    height: 200%;
    border: 1px solid #e5e5e5;
    transform: scale(0.5);
    transform-origin: 0 0;
    box-sizing: border-box;
}
```

### 3. viewport + rem方案

```html
<meta name="viewport" content="width=device-width, initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no">
```

```css
.hairline {
    border-bottom: 1px solid #e5e5e5;
}
```

**说明：**
- 通过缩放整个页面实现细线
- 需要调整所有尺寸为2倍
- 适合整个页面都需要细线的场景

### 4. border-image方案

```css
.hairline {
    border-bottom: 1px solid transparent;
    border-image: linear-gradient(to right, #e5e5e5, #e5e5e5) 0 0 1 0;
}

/* 支持的浏览器中使用 */
@supports (border-image: linear-gradient(to right, #000, #000) 1) {
    .hairline {
        border-bottom: 0.5px solid #e5e5e5;
        border-image: none;
    }
}
```

## 响应式适配

### 根据DPR动态设置

```css
/* 普通屏幕 */
.hairline {
    border-bottom: 1px solid #e5e5e5;
}

/* 2倍屏 */
@media (-webkit-min-device-pixel-ratio: 2) {
    .hairline {
        border-bottom: none;
        position: relative;
    }
    
    .hairline::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 1px;
        background: #e5e5e5;
        transform: scaleY(0.5);
    }
}

/* 3倍屏 */
@media (-webkit-min-device-pixel-ratio: 3) {
    .hairline::after {
        transform: scaleY(0.33);
    }
}
```

### JavaScript动态检测

```javascript
// 检测设备像素比
function getPixelRatio() {
    return window.devicePixelRatio || 1;
}

// 动态添加细线类
function addHairlineClass() {
    const dpr = getPixelRatio();
    const body = document.body;
    
    if (dpr >= 2) {
        body.classList.add('hairline-dpr2');
    }
    
    if (dpr >= 3) {
        body.classList.add('hairline-dpr3');
    }
}

// 初始化
addHairlineClass();
```

```css
/* 基于JavaScript检测的样式 */
.hairline-dpr2 .hairline::after {
    transform: scaleY(0.5);
}

.hairline-dpr3 .hairline::after {
    transform: scaleY(0.33);
}
```

## 实际应用场景

### 列表分割线

```css
.list-item {
    padding: 15px;
    position: relative;
}

.list-item:not(:last-child)::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 15px;
    right: 15px;
    height: 1px;
    background: #e5e5e5;
    transform: scaleY(0.5);
}
```

### 表格边框

```css
.table {
    border-collapse: separate;
    border-spacing: 0;
}

.table td {
    padding: 10px;
    position: relative;
}

/* 右边框 */
.table td:not(:last-child)::after {
    content: '';
    position: absolute;
    top: 0;
    right: 0;
    width: 1px;
    height: 100%;
    background: #e5e5e5;
    transform: scaleX(0.5);
}

/* 下边框 */
.table tr:not(:last-child) td::before {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 1px;
    background: #e5e5e5;
    transform: scaleY(0.5);
}
```

### 卡片边框

```css
.card {
    position: relative;
    padding: 20px;
    background: white;
}

.card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 200%;
    height: 200%;
    border: 1px solid #e5e5e5;
    border-radius: 16px; /* 2倍圆角 */
    transform: scale(0.5);
    transform-origin: 0 0;
    pointer-events: none;
}
```

## SCSS/LESS混合宏

### SCSS版本

```scss
@mixin hairline($direction: bottom, $color: #e5e5e5, $radius: 0) {
    position: relative;
    
    &::after {
        content: '';
        position: absolute;
        pointer-events: none;
        
        @if $direction == bottom {
            bottom: 0;
            left: 0;
            width: 100%;
            height: 1px;
            background: $color;
            transform: scaleY(0.5);
        } @else if $direction == top {
            top: 0;
            left: 0;
            width: 100%;
            height: 1px;
            background: $color;
            transform: scaleY(0.5);
        } @else if $direction == all {
            top: 0;
            left: 0;
            width: 200%;
            height: 200%;
            border: 1px solid $color;
            transform: scale(0.5);
            transform-origin: 0 0;
            
            @if $radius > 0 {
                border-radius: $radius * 2;
            }
        }
    }
}

// 使用示例
.list-item {
    @include hairline(bottom, #ddd);
}

.card {
    @include hairline(all, #e5e5e5, 8px);
}
```

### LESS版本

```less
.hairline(@direction: bottom, @color: #e5e5e5, @radius: 0) {
    position: relative;
    
    &::after {
        content: '';
        position: absolute;
        pointer-events: none;
        
        & when (@direction = bottom) {
            bottom: 0;
            left: 0;
            width: 100%;
            height: 1px;
            background: @color;
            transform: scaleY(0.5);
        }
        
        & when (@direction = all) {
            top: 0;
            left: 0;
            width: 200%;
            height: 200%;
            border: 1px solid @color;
            transform: scale(0.5);
            transform-origin: 0 0;
            
            & when (@radius > 0) {
                border-radius: @radius * 2;
            }
        }
    }
}
```

## 兼容性注意事项

### 浏览器支持

- **iOS Safari：** 完美支持
- **Android Chrome：** 支持良好
- **老版本Android：** 可能有细微差异
- **IE：** 不支持transform，需要回退方案

### 回退方案

```css
.hairline {
    border-bottom: 1px solid #e5e5e5;
}

/* 支持transform的浏览器 */
@supports (transform: scale(0.5)) {
    .hairline {
        border-bottom: none;
        position: relative;
    }
    
    .hairline::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 1px;
        background: #e5e5e5;
        transform: scaleY(0.5);
    }
}
```

## 性能优化

- **避免过度使用：** 过多伪元素影响性能
- **合理使用GPU加速：** transform自动启用硬件加速
- **减少重绘：** 使用transform而非border避免重排

## 最佳实践

1. **优先使用transform方案：** 兼容性和效果最佳
2. **统一处理：** 使用混合宏或工具类统一管理
3. **响应式适配：** 根据DPR动态调整
4. **性能考虑：** 避免在大量元素上使用