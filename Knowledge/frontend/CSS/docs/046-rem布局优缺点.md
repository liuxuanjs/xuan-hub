## 概述

rem（root em）布局是一种基于根元素字体大小的响应式布局方案。通过动态调整html元素的font-size，实现不同屏幕尺寸下的整体缩放效果。

## rem布局原理

### 基本概念

**rem单位：** 相对于根元素（html）的font-size尺寸

```css
/* 根元素设置 */
html {
    font-size: 16px; /* 1rem = 16px */
}

/* 使用rem单位 */
.container {
    width: 20rem;    /* 20 * 16px = 320px */
    height: 12.5rem; /* 12.5 * 16px = 200px */
    padding: 1rem;   /* 1 * 16px = 16px */
}
```

### 动态计算实现

```javascript
// 动态设置rem基准值
function setRem() {
    const baseSize = 16; // 设计稿基准字体大小
    const designWidth = 375; // 设计稿宽度
    const currentWidth = document.documentElement.clientWidth;
    
    // 计算缩放比例
    const scale = currentWidth / designWidth;
    const fontSize = baseSize * scale;
    
    // 设置根元素字体大小
    document.documentElement.style.fontSize = fontSize + 'px';
}

// 初始化和窗口变化时调用
setRem();
window.addEventListener('resize', setRem);
window.addEventListener('orientationchange', setRem);
```

### 简化版本

```javascript
// 更简洁的实现
(function(doc, win) {
    const docEl = doc.documentElement;
    const resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize';
    
    function recalc() {
        const clientWidth = docEl.clientWidth;
        if (!clientWidth) return;
        
        // 375px设计稿，1rem = 100px
        docEl.style.fontSize = 100 * (clientWidth / 375) + 'px';
    }
    
    win.addEventListener(resizeEvt, recalc, false);
    doc.addEventListener('DOMContentLoaded', recalc, false);
})(document, window);
```

## 优点分析

### 1. 整体缩放一致性

```css
/* 设计稿375px宽度，元素100px宽 */
.element {
    width: 1rem; /* 375px设备上 = 100px */
}

/* 在750px宽度设备上自动变为200px */
/* 保持相同的视觉比例 */
```

### 2. 兼容性良好

```css
/* 现代浏览器支持情况 */
/* iOS Safari 6+, Android 4.1+, Chrome 31+, Firefox 31+ */
.modern-support {
    width: 10rem;
    height: 5rem;
    font-size: 0.875rem; /* 14px */
}
```

### 3. 开发效率高

```javascript
// 自动转换工具
function pxToRem(px, baseSize = 100) {
    return px / baseSize;
}

// 使用示例
const width = pxToRem(200); // 2rem
const fontSize = pxToRem(28); // 0.28rem
```

## 缺点分析

### 1. 高DPR设备问题

```javascript
// 某些华为高端机型DPR异常
// iPhone 12 Pro Max: DPR = 3
// 某些华为手机: DPR = 2.75

function handleHighDPR() {
    const dpr = window.devicePixelRatio || 1;
    
    // 对特殊设备进行修正
    if (dpr > 3 || (dpr > 2 && dpr < 3)) {
        const viewport = document.querySelector('meta[name="viewport"]');
        const scale = 1 / dpr;
        viewport.setAttribute('content', 
            `width=device-width,initial-scale=${scale},maximum-scale=${scale},minimum-scale=${scale}`);
    }
}
```

### 2. iframe嵌入问题

```html
<!-- 主页面rem设置 -->
<html style="font-size: 50px;">
    <!-- iframe内容会继承主页面的rem基准 -->
    <iframe src="child.html"></iframe>
</html>
```

```javascript
// iframe内部需要重新计算
if (window.parent !== window) {
    // 在iframe中，重新计算rem
    document.documentElement.style.fontSize = '16px';
}
```

### 3. 设计哲学冲突

```css
/* rem布局：大屏幕上所有元素等比放大 */
.card {
    width: 10rem;  /* 在大屏上可能过大 */
    height: 8rem;
    font-size: 0.875rem;
}

/* 更合理的方式：设置最大宽度 */
.card {
    width: 10rem;
    max-width: 400px; /* 限制最大宽度 */
    margin: 0 auto;
}
```

## 现代替代方案

### 1. vw/vh单位

```css
/* vw: 1vw = 1% 视口宽度 */
.container {
    width: 50vw;     /* 50%视口宽度 */
    height: 30vh;    /* 30%视口高度 */
    font-size: 4vw;  /* 响应式字体 */
}

/* 结合使用更灵活 */
.text {
    font-size: calc(16px + 2vw); /* 基础 + 变化 */
}
```

### 2. CSS Grid + rem

```css
.grid-container {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1rem;
    padding: 1rem;
}

.grid-item {
    padding: 1.5rem;
    font-size: 1rem;
}
```

### 3. 容器查询（未来）

```css
@container (width > 400px) {
    .card {
        font-size: 1.2rem;
        padding: 2rem;
    }
}
```

## 实际应用案例

### 移动端商城

```javascript
// flexible.js 简化版
(function(win, lib) {
    const doc = win.document;
    const docEl = doc.documentElement;
    let metaEl = doc.querySelector('meta[name="viewport"]');
    
    const dpr = win.devicePixelRatio || 1;
    const scale = 1 / dpr;
    
    // 设置viewport
    if (!metaEl) {
        metaEl = doc.createElement('meta');
        metaEl.setAttribute('name', 'viewport');
        metaEl.setAttribute('content', 
            `width=device-width,user-scalable=no,initial-scale=${scale},maximum-scale=${scale},minimum-scale=${scale}`);
        docEl.firstElementChild.appendChild(metaEl);
    }
    
    function refreshRem() {
        const width = docEl.getBoundingClientRect().width;
        if (width / dpr > 540) {
            width = 540 * dpr;
        }
        const rem = width / 10;
        docEl.style.fontSize = rem + 'px';
    }
    
    win.addEventListener('resize', refreshRem);
    refreshRem();
    
})(window, window['lib'] || (window['lib'] = {}));
```

### PostCSS自动转换

```javascript
// postcss.config.js
module.exports = {
    plugins: [
        require('postcss-pxtorem')({
            rootValue: 100, // 根元素字体大小
            propList: ['*'], // 需要转换的属性
            selectorBlackList: ['.no-rem'] // 黑名单
        })
    ]
};
```

```css
/* 输入 */
.header {
    height: 100px;
    font-size: 28px;
    padding: 20px;
}

/* 输出 */
.header {
    height: 1rem;
    font-size: 0.28rem;
    padding: 0.2rem;
}
```

## 最佳实践

### 1. 合理设置基准值

```javascript
// 推荐配置
const remConfig = {
    designWidth: 375,    // 设计稿宽度
    baseSize: 100,       // rem基准值
    maxWidth: 540,       // 最大宽度限制
    minWidth: 320        // 最小宽度限制
};

function setRemUnit() {
    const deviceWidth = document.documentElement.clientWidth;
    const width = Math.max(remConfig.minWidth, 
                  Math.min(deviceWidth, remConfig.maxWidth));
    const fontSize = (width / remConfig.designWidth) * remConfig.baseSize;
    document.documentElement.style.fontSize = fontSize + 'px';
}
```

### 2. 组合使用策略

```css
/* rem + px 组合 */
.component {
    width: 10rem;        /* 响应式宽度 */
    border: 1px solid;   /* 固定边框 */
    border-radius: 4px;  /* 固定圆角 */
}

/* rem + vw 组合 */
.fluid-text {
    font-size: calc(1rem + 1vw);
}
```

### 3. 性能优化

```javascript
// 节流处理
let resizeTimer;
function throttledSetRem() {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(setRemUnit, 100);
}

window.addEventListener('resize', throttledSetRem);
```

## 对比分析

| 特性 | rem布局 | vw/vh | px固定 | 百分比 |
|------|----------|-------|---------|----------|
| 响应式 | ✓ 整体缩放 | ✓ 绿滑 | ✗ 不响应 | ✓ 流式 |
| 兼容性 | ✓ 好 | ✓ 好 | ✓ 完美 | ✓ 完美 |
| 维护性 | ○ 一般 | ✓ 简单 | ✓ 简单 | ○ 一般 |
| 性能 | ○ JS计算 | ✓ 原生 | ✓ 最佳 | ✓ 原生 |
| 灵活性 | ○ 一般 | ✓ 高 | ✗ 低 | ✓ 高 |

## 选择建议

**适合rem布局的场景：**
- 移动端专用页面
- 需要整体缩放的设计
- 设计稿尺寸固定的项目

**不适合rem布局的场景：**
- 响应式桌面端网站
- 内容为主的阅读类网站
- 需要精确像素控制的场景

rem布局在移动端开发中仍然是一种有效的解决方案，但需要根据具体项目需求和目标用户群体进行选择。

## 标签
#CSS #前端面试