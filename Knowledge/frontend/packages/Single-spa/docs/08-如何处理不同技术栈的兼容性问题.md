
### 1. 技术栈隔离

```typescript
// Business 端支持 Angular + React 混合
export class RootApp extends React.Component {
  // React 主应用管理 Angular 子应用
  public async componentDidMount() {
    bootstrapSpaService('Business');
  }
}
```

**隔离策略：**

- 每个应用独立的技术栈选择
- 通过容器隔离运行环境
- 标准化的接口约定

### 2. 依赖管理策略

```javascript
// Webpack 外部依赖配置
externals: {
  'react': 'React',
  'react-dom': 'ReactDOM',
  'angular': 'angular'
}

// 共享依赖版本管理
const sharedDependencies = {
  'react': '^16.13.1',
  'angular': '^1.5.8',
  'lodash': '^4.17.21'
};
```

**版本策略：**

- 主要框架版本统一管理
- 工具库版本兼容性检查
- peerDependencies 明确依赖关系

### 3. API 标准化

```typescript
// 统一的服务接口
interface IPortalService {
  ThemeService: IThemeService;
  LanguageService: ILanguageService;
  AuthService: IAuthService;
}

// 不同技术栈的适配器
class AngularServiceAdapter {
  constructor(private portalService: IPortalService) {}

  // 将 Portal 服务适配为 Angular 服务
  getAngularService() {
    return {
      theme: this.portalService.ThemeService,
      i18n: this.portalService.LanguageService,
    };
  }
}
```

### 4. 渐进式迁移

**迁移策略：**

```typescript
// 新功能使用 React 开发
const NewFeatureApp = () => {
  return <div>使用 React 开发的新功能</div>;
};

// 老功能保持 Angular 不变
angular.module('legacyApp', []).component('legacyFeature', {
  template: '<div>保持 Angular 的老功能</div>',
});

// 通过配置控制技术栈选择
const appConfig = {
  'new-feature': { framework: 'react' },
  'legacy-feature': { framework: 'angular' },
};
```

### 5. 跨框架通信

```typescript
// React 组件调用 Angular 服务
class ReactComponent extends React.Component {
  componentDidMount() {
    // 获取 Angular 注入器
    const injector = angular.element(document.body).injector();
    const angularService = injector.get('MyAngularService');

    // 调用 Angular 服务
    angularService.doSomething();
  }
}

// Angular 组件使用 React 服务
angular.module('app').controller('MyController', [
  '$scope',
  function ($scope) {
    // 通过全局对象访问 React 服务
    const reactService = window.KyPortalService.ReactService;
    $scope.data = reactService.getData();
  },
]);
```

### 6. 样式兼容性

```scss
// Angular 应用样式隔离
.angular-app {
  // Angular 特有样式
  .ng-scope {
    /* Angular 样式 */
  }
}

// React 应用样式隔离
.react-app {
  // React 特有样式
  .react-component {
    /* React 样式 */
  }
}
```

**样式管理：**

- CSS-in-JS（React）+ 传统 CSS（Angular）
- 样式命名空间隔离
- 共享设计系统和主题

### 7. 构建兼容性

```javascript
// 多技术栈构建配置
const webpackConfig = {
  entry: {
    'react-app': './src/react/index.tsx',
    'angular-app': './src/angular/index.js',
  },

  module: {
    rules: [
      // TypeScript 处理（React）
      {
        test: /\.tsx?$/,
        use: 'ts-loader',
        exclude: /node_modules/,
      },
      // JavaScript 处理（Angular）
      {
        test: /\.js$/,
        use: 'babel-loader',
        exclude: /node_modules/,
      },
    ],
  },
};
```

### 8. 测试兼容性

```typescript
// React 组件测试
import { render, screen } from '@testing-library/react';

test('React 组件测试', () => {
  render(<MyReactComponent />);
  expect(screen.getByText('Hello')).toBeInTheDocument();
});

// Angular 组件测试
describe('Angular Controller', () => {
  let $controller, $rootScope;

  beforeEach(inject((_$controller_, _$rootScope_) => {
    $controller = _$controller_;
    $rootScope = _$rootScope_;
  }));

  it('should work', () => {
    const $scope = $rootScope.$new();
    const controller = $controller('MyController', { $scope });
    expect(controller).toBeDefined();
  });
});
```

### 兼容性解决方案总结

| 兼容性问题     | 解决方案     | 技术手段              |
| -------------- | ------------ | --------------------- |
| 框架版本冲突   | 版本统一管理 | package.json + lerna  |
| API 接口不一致 | 接口标准化   | TypeScript 接口定义   |
| 样式污染       | 样式隔离     | CSS Module + 命名空间 |
| 构建差异       | 统一构建配置 | Webpack 多入口配置    |
| 测试框架不同   | 分层测试策略 | Jest + Karma 并行     |

### 技术栈选择原则

1. **新项目优先使用现代技术栈**（React + TypeScript）
2. **老项目保持稳定**，避免大规模重构
3. **关键路径优先迁移**，非关键功能延后
4. **团队技能匹配**，选择团队熟悉的技术栈

[← 上一个问题：团队协作机制](07-团队协作和开发效率如何提升.md) | [下一个问题：监控和调试 →](09-微前端架构的监控和调试如何实现.md)
