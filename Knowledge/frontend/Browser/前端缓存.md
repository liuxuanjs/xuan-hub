---
aliases:
title: 前端缓存
tags: [前端性能, 缓存, HTTP, Service Worker, CDN]
updated: 2025-09-19
---

# 前端缓存

## 概览
- 目标：减少请求、加速加载、降低服务器与带宽成本。
- 结论摘要：
  - HTML 禁缓存或协商缓存；静态资源带 `contenthash` 强缓存一年。
  - 优先 `Cache-Control`；用 `ETag/If-None-Match` 做回源校验。
  - CDN 前置，边缘缓存+回源验证；Service Worker 兜底离线。
- 适用范围：Web 应用、SPA、PWA；不涵盖 Node 端缓存。

## 核心概念
- 强缓存 Strong Cache：命中后直接用本地，不发请求。
- 协商缓存 Negotiation Cache：对比 `ETag` 或 `Last-Modified` 决定 304/200。
- CDN 缓存：边缘节点按响应头与规则缓存，减少回源。
- Service Worker：脚本化缓存，策略可编排，支持离线与降级。
- 存储 API：`localStorage`/`sessionStorage`/`IndexedDB` 存业务态与大数据。

## 操作/实现
1. 前置条件
   - 服务器可配置响应头；构建工具支持 `contenthash`；CDN 可设置缓存策略。
2. 步骤
   - 构建产物使用文件名哈希（`[contenthash]`）。
   - HTML 设置 `Cache-Control: no-cache, no-store, must-revalidate`。
   - 静态资源设置 `Cache-Control: public, max-age=31536000, immutable`。
   - 开启 `ETag` 或 `Last-Modified` 作为协商回源依据。
   - CDN 对静态资源长期缓存，对 HTML 不缓存或仅回源验证。
   - 可选：Service Worker 对关键资源实施离线兜底（见下文示例）。
3. 验证
   - DevTools Network：`Status` 为 `(from disk/memory cache)` 或 `304`。
   - `response.headers` 含期望 `Cache-Control` 与 `ETag`/`Last-Modified`。
   - 刷新/强刷对比命中率；观察首包与回源变化。
4. 回滚
   - 立即失效：下发 `Cache-Control: no-cache, no-store`；CDN 清缓存。
   - 版本回滚：切回旧版本路径或降级哈希资源；SW 主动失活与清理。

## 为什么需要缓存？

### 核心价值
- **提升用户体验**：减少页面加载时间，提供即时响应
- **降低服务器压力**：减少重复请求，节省服务器资源和带宽
- **优化网络性能**：充分利用本地存储，减少网络传输
- **节约成本**：降低CDN和服务器的使用成本

## 浏览器缓存机制

### 1. 强缓存（Strong Cache）

强缓存是最高效的缓存方式，浏览器直接从本地缓存中获取资源，不会发送任何网络请求。

#### 控制字段

**Cache-Control（推荐）**
```http
Cache-Control: max-age=31536000  // 缓存一年
Cache-Control: no-cache          // 需要协商缓存
Cache-Control: no-store          // 不缓存
Cache-Control: public            // 可被任何缓存存储
Cache-Control: private           // 只能被浏览器缓存
```

**Expires（已过时）**
```http
Expires: Wed, 21 Oct 2025 07:28:00 GMT
```

#### 常用配置组合
```http
// 静态资源长期缓存
Cache-Control: public, max-age=31536000

// HTML文件不缓存
Cache-Control: no-cache, no-store, must-revalidate

// API数据短期缓存
Cache-Control: private, max-age=300
```

### 2. 协商缓存（Negotiation Cache）

当强缓存失效时，浏览器会向服务器发送请求，通过对比资源的修改时间或标识符来判断是否需要更新资源。

#### ETag / If-None-Match（推荐）

**服务器响应**
```http
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
```

**浏览器请求**
```http
If-None-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4"
```

#### Last-Modified / If-Modified-Since

**服务器响应**
```http
Last-Modified: Wed, 21 Oct 2024 07:28:00 GMT
```

**浏览器请求**
```http
If-Modified-Since: Wed, 21 Oct 2024 07:28:00 GMT
```

### 3. 缓存流程图

```
浏览器请求资源
     ↓
检查是否有缓存
     ↓
有缓存 → 检查是否过期
     ↓              ↓
   未过期          已过期
     ↓              ↓
  使用缓存    → 发送协商请求
                    ↓
              服务器检查资源
                    ↓
            资源未改变 | 资源已改变
                    ↓          ↓
               返回304    返回200+新资源
                    ↓          ↓
              使用本地缓存   更新缓存
```

## 浏览器存储方式

### 1. HTTP缓存
- **位置**：浏览器内置缓存机制
- **特点**：自动管理，遵循HTTP协议
- **适用**：静态资源、API响应

### 2. Service Worker缓存
- **位置**：独立的工作线程
- **特点**：编程式控制，支持离线访问
- **适用**：PWA应用、复杂缓存策略

```javascript
// Service Worker 缓存示例
self.addEventListener('fetch', event => {
  if (event.request.destination === 'image') {
    event.respondWith(
      caches.match(event.request).then(response => {
        return response || fetch(event.request).then(fetchResponse => {
          const responseClone = fetchResponse.clone();
          caches.open('images-v1').then(cache => {
            cache.put(event.request, responseClone);
          });
          return fetchResponse;
        });
      })
    );
  }
});
```

### 3. 浏览器存储API
- **localStorage**：持久化存储，手动管理
- **sessionStorage**：会话级存储
- **IndexedDB**：大容量结构化数据存储

## 缓存策略最佳实践

### 1. 资源分类缓存策略

| 资源类型 | 缓存策略 | 示例配置 |
|---------|---------|---------|
| HTML页面 | 不缓存或协商缓存 | `Cache-Control: no-cache` |
| CSS/JS（带hash） | 强缓存一年 | `Cache-Control: public, max-age=31536000` |
| 图片/字体（带hash） | 强缓存一年 | `Cache-Control: public, max-age=31536000` |
| API数据 | 短期缓存或不缓存 | `Cache-Control: private, max-age=300` |
| 第三方库（CDN） | 长期缓存 | `Cache-Control: public, max-age=2592000` |

### 2. 版本控制策略

#### 文件名哈希化
```javascript
// Webpack配置示例
module.exports = {
  output: {
    filename: '[name].[contenthash:8].js',
    chunkFilename: '[name].[contenthash:8].chunk.js'
  }
};
```

#### 版本号管理
```html
<!-- 查询参数版本控制 -->
<script src="/js/app.js?v=1.2.3"></script>

<!-- 路径版本控制 -->
<script src="/v1.2.3/js/app.js"></script>
```

### 3. CDN配合缓存

```nginx
# Nginx配置示例
location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
    expires 1y;
    add_header Cache-Control "public, immutable";
    add_header Vary Accept-Encoding;
}

location ~* \.html$ {
    expires -1;
    add_header Cache-Control "no-cache, no-store, must-revalidate";
}
```

## 缓存更新策略

### 1. 缓存失效问题

**问题场景**：
- 用户访问旧版本的缓存文件
- 新功能无法正常使用
- 样式或脚本不匹配

**解决方案**：
- 文件内容哈希化
- 版本号管理
- 缓存清除机制

### 2. 渐进式更新

```javascript
// Service Worker 更新策略
self.addEventListener('install', event => {
  event.waitUntil(
    caches.open('v2').then(cache => {
      return cache.addAll([
        '/css/app.css',
        '/js/app.js',
        '/images/logo.png'
      ]);
    })
  );
});

self.addEventListener('activate', event => {
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          if (cacheName !== 'v2') {
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});
```

## 缓存调试与监控

### 1. 浏览器开发者工具

**Network面板**：
- 查看资源加载状态
- 检查缓存命中情况
- 分析请求头和响应头

**Application面板**：
- 查看各种存储内容
- 清除特定缓存
- 管理Service Worker

### 2. 性能监控

```javascript
// 缓存命中率监控
function trackCacheHit(resource, hitType) {
  analytics.track('cache_performance', {
    resource: resource,
    hit_type: hitType, // 'hit', 'miss', 'refresh'
    timestamp: Date.now()
  });
}

// Performance API监控
const observer = new PerformanceObserver((list) => {
  list.getEntries().forEach((entry) => {
    if (entry.transferSize === 0) {
      trackCacheHit(entry.name, 'hit');
    } else {
      trackCacheHit(entry.name, 'miss');
    }
  });
});
observer.observe({entryTypes: ['navigation', 'resource']});
```

## 故障与 FAQ

### 1. 缓存过度问题
**现象**：用户无法获取最新内容
**解决**：
- 合理设置缓存时间
- 重要更新时清除缓存
- 使用版本控制

### 2. 缓存不足问题
**现象**：重复请求相同资源
**解决**：
- 检查缓存头设置
- 确保服务器正确响应
- 优化缓存策略

### 3. 移动端缓存问题
**现象**：移动浏览器缓存行为不一致
**解决**：
- 测试不同浏览器
- 使用标准化缓存头
- 考虑使用Service Worker

## 性能优化建议

### 1. 预加载策略
```html
<!-- DNS预解析 -->
<link rel="dns-prefetch" href="//cdn.example.com">

<!-- 预加载关键资源 -->
<link rel="preload" href="/css/critical.css" as="style">
<link rel="preload" href="/js/app.js" as="script">

<!-- 预获取后续页面资源 -->
<link rel="prefetch" href="/js/page2.js">
```

### 2. 资源压缩与合并
```javascript
// Webpack优化配置
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
        },
      },
    },
  },
};
```

### 3. 图片优化
```html
<!-- 响应式图片 -->
<picture>
  <source srcset="image.webp" type="image/webp">
  <source srcset="image.avif" type="image/avif">
  <img src="image.jpg" alt="description">
</picture>

<!-- 懒加载 -->
<img src="placeholder.jpg" data-src="actual-image.jpg" loading="lazy">
```

## 总结
- 资源分层：HTML 协商；静态资源强缓存+哈希；API 谨慎缓存。
- 更新安全：内容哈希+版本号+灰度；配合 CDN 与 SW 策略。
- 持续监控：命中率/回源率/错误码；定期抽检与回归。

## 附录

- [MDN - HTTP缓存](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching)
- [Google Web Fundamentals - HTTP缓存](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching)
- [Service Worker API](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API)
- [掘金 - 前端缓存详解](https://juejin.cn/post/7241118721171030075)

## 变更记录
- 2025-09-19：按知识库规则重构，新增 frontmatter/概览/操作与回滚/FAQ/附录，精简总结。
