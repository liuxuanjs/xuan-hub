# 前端缓存

## 概述

前端缓存是现代Web开发中提升用户体验和网站性能的核心技术之一。通过合理的缓存策略，我们可以显著减少网络请求、提高页面加载速度、降低服务器负载，为用户提供更流畅的浏览体验。

## 为什么需要缓存？

### 核心价值
- **提升用户体验**：减少页面加载时间，提供即时响应
- **降低服务器压力**：减少重复请求，节省服务器资源和带宽
- **优化网络性能**：充分利用本地存储，减少网络传输
- **节约成本**：降低CDN和服务器的使用成本

## 浏览器缓存机制

### 1. 强缓存（Strong Cache）

强缓存是最高效的缓存方式，浏览器直接从本地缓存中获取资源，不会发送任何网络请求。

#### 控制字段

**Cache-Control（推荐）**
```http
Cache-Control: max-age=31536000  // 缓存一年
Cache-Control: no-cache          // 需要协商缓存
Cache-Control: no-store          // 不缓存
Cache-Control: public            // 可被任何缓存存储
Cache-Control: private           // 只能被浏览器缓存
```

**Expires（已过时）**
```http
Expires: Wed, 21 Oct 2025 07:28:00 GMT
```

#### 常用配置组合
```http
// 静态资源长期缓存
Cache-Control: public, max-age=31536000

// HTML文件不缓存
Cache-Control: no-cache, no-store, must-revalidate

// API数据短期缓存
Cache-Control: private, max-age=300
```

### 2. 协商缓存（Negotiation Cache）

当强缓存失效时，浏览器会向服务器发送请求，通过对比资源的修改时间或标识符来判断是否需要更新资源。

#### ETag / If-None-Match（推荐）

**服务器响应**
```http
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
```

**浏览器请求**
```http
If-None-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4"
```

#### Last-Modified / If-Modified-Since

**服务器响应**
```http
Last-Modified: Wed, 21 Oct 2024 07:28:00 GMT
```

**浏览器请求**
```http
If-Modified-Since: Wed, 21 Oct 2024 07:28:00 GMT
```

### 3. 缓存流程图

```
浏览器请求资源
     ↓
检查是否有缓存
     ↓
有缓存 → 检查是否过期
     ↓              ↓
   未过期          已过期
     ↓              ↓
  使用缓存    → 发送协商请求
                    ↓
              服务器检查资源
                    ↓
            资源未改变 | 资源已改变
                    ↓          ↓
               返回304    返回200+新资源
                    ↓          ↓
              使用本地缓存   更新缓存
```

## 浏览器存储方式

### 1. HTTP缓存
- **位置**：浏览器内置缓存机制
- **特点**：自动管理，遵循HTTP协议
- **适用**：静态资源、API响应

### 2. Service Worker缓存
- **位置**：独立的工作线程
- **特点**：编程式控制，支持离线访问
- **适用**：PWA应用、复杂缓存策略

```javascript
// Service Worker 缓存示例
self.addEventListener('fetch', event => {
  if (event.request.destination === 'image') {
    event.respondWith(
      caches.match(event.request).then(response => {
        return response || fetch(event.request).then(fetchResponse => {
          const responseClone = fetchResponse.clone();
          caches.open('images-v1').then(cache => {
            cache.put(event.request, responseClone);
          });
          return fetchResponse;
        });
      })
    );
  }
});
```

### 3. 浏览器存储API
- **localStorage**：持久化存储，手动管理
- **sessionStorage**：会话级存储
- **IndexedDB**：大容量结构化数据存储

## 缓存策略最佳实践

### 1. 资源分类缓存策略

| 资源类型 | 缓存策略 | 示例配置 |
|---------|---------|---------|
| HTML页面 | 不缓存或协商缓存 | `Cache-Control: no-cache` |
| CSS/JS（带hash） | 强缓存一年 | `Cache-Control: public, max-age=31536000` |
| 图片/字体（带hash） | 强缓存一年 | `Cache-Control: public, max-age=31536000` |
| API数据 | 短期缓存或不缓存 | `Cache-Control: private, max-age=300` |
| 第三方库（CDN） | 长期缓存 | `Cache-Control: public, max-age=2592000` |

### 2. 版本控制策略

#### 文件名哈希化
```javascript
// Webpack配置示例
module.exports = {
  output: {
    filename: '[name].[contenthash:8].js',
    chunkFilename: '[name].[contenthash:8].chunk.js'
  }
};
```

#### 版本号管理
```html
<!-- 查询参数版本控制 -->
<script src="/js/app.js?v=1.2.3"></script>

<!-- 路径版本控制 -->
<script src="/v1.2.3/js/app.js"></script>
```

### 3. CDN配合缓存

```nginx
# Nginx配置示例
location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
    expires 1y;
    add_header Cache-Control "public, immutable";
    add_header Vary Accept-Encoding;
}

location ~* \.html$ {
    expires -1;
    add_header Cache-Control "no-cache, no-store, must-revalidate";
}
```

## 缓存更新策略

### 1. 缓存失效问题

**问题场景**：
- 用户访问旧版本的缓存文件
- 新功能无法正常使用
- 样式或脚本不匹配

**解决方案**：
- 文件内容哈希化
- 版本号管理
- 缓存清除机制

### 2. 渐进式更新

```javascript
// Service Worker 更新策略
self.addEventListener('install', event => {
  event.waitUntil(
    caches.open('v2').then(cache => {
      return cache.addAll([
        '/css/app.css',
        '/js/app.js',
        '/images/logo.png'
      ]);
    })
  );
});

self.addEventListener('activate', event => {
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          if (cacheName !== 'v2') {
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});
```

## 缓存调试与监控

### 1. 浏览器开发者工具

**Network面板**：
- 查看资源加载状态
- 检查缓存命中情况
- 分析请求头和响应头

**Application面板**：
- 查看各种存储内容
- 清除特定缓存
- 管理Service Worker

### 2. 性能监控

```javascript
// 缓存命中率监控
function trackCacheHit(resource, hitType) {
  analytics.track('cache_performance', {
    resource: resource,
    hit_type: hitType, // 'hit', 'miss', 'refresh'
    timestamp: Date.now()
  });
}

// Performance API监控
const observer = new PerformanceObserver((list) => {
  list.getEntries().forEach((entry) => {
    if (entry.transferSize === 0) {
      trackCacheHit(entry.name, 'hit');
    } else {
      trackCacheHit(entry.name, 'miss');
    }
  });
});
observer.observe({entryTypes: ['navigation', 'resource']});
```

## 常见问题与解决方案

### 1. 缓存过度问题
**现象**：用户无法获取最新内容
**解决**：
- 合理设置缓存时间
- 重要更新时清除缓存
- 使用版本控制

### 2. 缓存不足问题
**现象**：重复请求相同资源
**解决**：
- 检查缓存头设置
- 确保服务器正确响应
- 优化缓存策略

### 3. 移动端缓存问题
**现象**：移动浏览器缓存行为不一致
**解决**：
- 测试不同浏览器
- 使用标准化缓存头
- 考虑使用Service Worker

## 性能优化建议

### 1. 预加载策略
```html
<!-- DNS预解析 -->
<link rel="dns-prefetch" href="//cdn.example.com">

<!-- 预加载关键资源 -->
<link rel="preload" href="/css/critical.css" as="style">
<link rel="preload" href="/js/app.js" as="script">

<!-- 预获取后续页面资源 -->
<link rel="prefetch" href="/js/page2.js">
```

### 2. 资源压缩与合并
```javascript
// Webpack优化配置
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
        },
      },
    },
  },
};
```

### 3. 图片优化
```html
<!-- 响应式图片 -->
<picture>
  <source srcset="image.webp" type="image/webp">
  <source srcset="image.avif" type="image/avif">
  <img src="image.jpg" alt="description">
</picture>

<!-- 懒加载 -->
<img src="placeholder.jpg" data-src="actual-image.jpg" loading="lazy">
```

## 总结

前端缓存是一个复杂而重要的主题，需要根据具体的业务场景和技术架构来制定合适的缓存策略。通过合理运用强缓存、协商缓存以及各种浏览器存储技术，我们可以显著提升Web应用的性能和用户体验。

**关键要点**：
1. 理解不同缓存机制的特点和适用场景
2. 制定分层的缓存策略
3. 合理处理缓存更新和版本控制
4. 持续监控和优化缓存效果
5. 考虑不同浏览器和设备的兼容性

通过不断实践和优化，前端缓存将成为提升Web应用性能的有力工具。

## 参考资料

- [MDN - HTTP缓存](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching)
- [Google Web Fundamentals - HTTP缓存](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching)
- [Service Worker API](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API)
- [掘金 - 前端缓存详解](https://juejin.cn/post/7241118721171030075)
