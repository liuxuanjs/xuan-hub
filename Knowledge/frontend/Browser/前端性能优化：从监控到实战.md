# 前端性能优化：从监控到实战

## 概述

前端性能优化是Web开发中至关重要的一环，它直接影响用户体验、搜索引擎排名和业务转化率。本文将从理论到实践，全面介绍前端性能优化的方法和工具。

## 目录

1. [性能指标体系](#性能指标体系)
2. [内存管理与泄漏检测](#内存管理与泄漏检测)
3. [渲染性能优化](#渲染性能优化)
4. [网络性能优化](#网络性能优化)
5. [性能监控工具](#性能监控工具)
6. [实战案例](#实战案例)

## 性能指标体系

### Core Web Vitals

Google提出的核心Web指标，用于衡量用户体验：

#### 1. Largest Contentful Paint (LCP)
- **定义**：最大内容绘制时间
- **标准**：< 2.5秒为优秀
- **影响因素**：
  - 服务器响应时间
  - 资源加载时间
  - 客户端渲染时间

```javascript
// 监控LCP
new PerformanceObserver((entryList) => {
  for (const entry of entryList.getEntries()) {
    console.log('LCP:', entry.startTime);
  }
}).observe({entryTypes: ['largest-contentful-paint']});
```

#### 2. First Input Delay (FID)
- **定义**：首次输入延迟
- **标准**：< 100毫秒为优秀
- **优化策略**：
  - 减少主线程阻塞
  - 代码分割
  - 延迟加载非关键资源

```javascript
// 监控FID
new PerformanceObserver((entryList) => {
  for (const entry of entryList.getEntries()) {
    console.log('FID:', entry.processingStart - entry.startTime);
  }
}).observe({entryTypes: ['first-input']});
```

#### 3. Cumulative Layout Shift (CLS)
- **定义**：累积布局偏移
- **标准**：< 0.1为优秀
- **优化方法**：
  - 为图片和视频设置尺寸
  - 为动态内容预留空间
  - 避免在现有内容上方插入内容

```javascript
// 监控CLS
let clsValue = 0;
new PerformanceObserver((entryList) => {
  for (const entry of entryList.getEntries()) {
    if (!entry.hadRecentInput) {
      clsValue += entry.value;
      console.log('CLS:', clsValue);
    }
  }
}).observe({entryTypes: ['layout-shift']});
```

### 其他重要指标

#### First Contentful Paint (FCP)
- **定义**：首次内容绘制时间，指浏览器首次渲染任何文本、图片、非白色canvas或SVG内容的时间点
- **重要性**：FCP是用户感知页面加载速度的第一个关键指标，直接影响用户对页面响应性的第一印象
- **标准**：
  - 优秀：< 1.8秒
  - 需要改进：1.8秒 - 3.0秒
  - 较差：> 3.0秒

**影响因素分析：**
1. **网络延迟**：DNS解析、TCP连接、TLS握手时间
2. **服务器响应时间**：TTFB（Time to First Byte）
3. **关键资源加载**：HTML、CSS、关键JavaScript文件
4. **渲染阻塞资源**：未优化的CSS和JavaScript
5. **资源大小**：过大的HTML、CSS、图片文件

**优化策略：**
```javascript
// 1. 监控FCP
new PerformanceObserver((entryList) => {
  for (const entry of entryList.getEntries()) {
    if (entry.name === 'first-contentful-paint') {
      console.log('FCP:', entry.startTime);
      // 发送到分析服务
      this.sendMetric('fcp', entry.startTime);
    }
  }
}).observe({entryTypes: ['paint']});

// 2. 关键CSS内联
function inlineCriticalCSS() {
  const criticalCSS = `
    body { font-family: Arial, sans-serif; }
    .header { background: #333; color: white; }
    .hero { height: 400px; background: linear-gradient(45deg, #ff6b6b, #4ecdc4); }
  `;
  
  const style = document.createElement('style');
  style.textContent = criticalCSS;
  document.head.insertBefore(style, document.head.firstChild);
}

// 3. 预加载关键资源
function preloadCriticalResources() {
  const criticalResources = [
    { href: '/fonts/main.woff2', as: 'font', type: 'font/woff2' },
    { href: '/images/hero.jpg', as: 'image' },
    { href: '/styles/critical.css', as: 'style' }
  ];
  
  criticalResources.forEach(resource => {
    const link = document.createElement('link');
    link.rel = 'preload';
    link.href = resource.href;
    link.as = resource.as;
    if (resource.type) link.type = resource.type;
    document.head.appendChild(link);
  });
}

// 4. 延迟非关键资源
function deferNonCriticalResources() {
  // 延迟加载非关键CSS
  const nonCriticalCSS = document.querySelectorAll('link[rel="stylesheet"][data-defer]');
  nonCriticalCSS.forEach(link => {
    link.media = 'print';
    link.onload = function() {
      this.media = 'all';
    };
  });
  
  // 延迟加载非关键JavaScript
  const nonCriticalJS = document.querySelectorAll('script[data-defer]');
  nonCriticalJS.forEach(script => {
    script.defer = true;
  });
}

// 5. 服务端渲染优化
function optimizeSSR() {
  // 确保关键内容在HTML中直接渲染
  // 避免客户端渲染阻塞FCP
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <title>页面标题</title>
      <style>${getCriticalCSS()}</style>
    </head>
    <body>
      <header>关键导航内容</header>
      <main>主要内容</main>
      <script src="/js/critical.js"></script>
    </body>
    </html>
  `;
}

// 6. 资源优先级管理
function setResourcePriority() {
  // 高优先级：关键CSS和JS
  const criticalCSS = document.querySelector('link[href*="critical"]');
  if (criticalCSS) criticalCSS.setAttribute('fetchpriority', 'high');
  
  // 低优先级：非关键图片
  const images = document.querySelectorAll('img[data-low-priority]');
  images.forEach(img => img.setAttribute('fetchpriority', 'low'));
}

// 7. FCP性能分析工具
class FCPAnalyzer {
  constructor() {
    this.metrics = {};
    this.init();
  }
  
  init() {
    this.observeFCP();
    this.analyzeBlockingResources();
  }
  
  observeFCP() {
    new PerformanceObserver((entryList) => {
      for (const entry of entryList.getEntries()) {
        if (entry.name === 'first-contentful-paint') {
          this.metrics.fcp = entry.startTime;
          this.analyzeFCPFactors();
        }
      }
    }).observe({entryTypes: ['paint']});
  }
  
  analyzeBlockingResources() {
    const resources = performance.getEntriesByType('resource');
    const blockingResources = resources.filter(resource => {
      // 检查是否在FCP之前完成
      return resource.responseEnd > this.metrics.fcp;
    });
    
    console.log('阻塞FCP的资源:', blockingResources);
  }
  
  analyzeFCPFactors() {
    const navigation = performance.getEntriesByType('navigation')[0];
    const factors = {
      dns: navigation.domainLookupEnd - navigation.domainLookupStart,
      tcp: navigation.connectEnd - navigation.connectStart,
      ttfb: navigation.responseStart - navigation.requestStart,
      domParse: navigation.domContentLoadedEventStart - navigation.responseEnd
    };
    
    console.log('FCP影响因素分析:', factors);
  }
  
  getOptimizationSuggestions() {
    const suggestions = [];
    
    if (this.metrics.fcp > 1800) {
      suggestions.push('FCP超过1.8秒，建议优化关键资源加载');
    }
    
    // 基于分析结果提供具体建议
    return suggestions;
  }
}
```

#### Time to Interactive (TTI)
- **定义**：页面变为完全交互状态的时间点，即页面加载完成且主线程空闲足够长时间（至少5秒）来响应用户输入
- **重要性**：TTI反映了用户何时可以真正与页面进行交互，是衡量页面可用性的关键指标
- **标准**：
  - 优秀：< 3.8秒
  - 需要改进：3.8秒 - 7.3秒
  - 较差：> 7.3秒

**TTI计算条件：**
1. 页面已经显示有用内容（FCP已完成）
2. 大多数可见元素的事件处理器已注册
3. 页面在50ms内响应用户交互

**影响因素分析：**
1. **JavaScript执行时间**：大量同步JavaScript代码
2. **长任务**：阻塞主线程超过50ms的任务
3. **资源加载**：未优化的JavaScript和CSS资源
4. **第三方脚本**：分析工具、广告、社交媒体插件
5. **内存使用**：内存泄漏导致垃圾回收频繁

**优化策略：**
```javascript
// 1. 完整的TTI监控实现
class TTIMonitor {
  constructor() {
    this.metrics = {};
    this.longTasks = [];
    this.init();
  }
  
  init() {
    this.observeLongTasks();
    this.observeNavigationTiming();
    this.calculateTTI();
  }
  
  observeLongTasks() {
    new PerformanceObserver((entryList) => {
      for (const entry of entryList.getEntries()) {
        this.longTasks.push({
          startTime: entry.startTime,
          duration: entry.duration,
          name: entry.name
        });
      }
    }).observe({entryTypes: ['longtask']});
  }
  
  observeNavigationTiming() {
    window.addEventListener('load', () => {
      const timing = performance.getEntriesByType('navigation')[0];
      this.metrics.domContentLoaded = timing.domContentLoadedEventEnd - timing.navigationStart;
      this.metrics.loadComplete = timing.loadEventEnd - timing.navigationStart;
    });
  }
  
  calculateTTI() {
    // 等待页面稳定后计算TTI
    setTimeout(() => {
      const fcp = this.getFCP();
      const lastLongTask = this.getLastLongTask();
      
      if (fcp && lastLongTask) {
        this.metrics.tti = Math.max(fcp, lastLongTask.startTime + lastLongTask.duration) + 5000;
        console.log('TTI:', this.metrics.tti);
      }
    }, 1000);
  }
  
  getFCP() {
    const paintEntries = performance.getEntriesByType('paint');
    const fcpEntry = paintEntries.find(entry => entry.name === 'first-contentful-paint');
    return fcpEntry ? fcpEntry.startTime : null;
  }
  
  getLastLongTask() {
    return this.longTasks[this.longTasks.length - 1] || null;
  }
}

// 2. 代码分割和懒加载
class CodeSplitting {
  static async loadRoute(routeName) {
    try {
      // 动态导入路由组件
      const module = await import(`./routes/${routeName}.js`);
      return module.default;
    } catch (error) {
      console.error(`Failed to load route ${routeName}:`, error);
    }
  }
  
  static preloadRoute(routeName) {
    // 预加载可能需要的路由
    const link = document.createElement('link');
    link.rel = 'modulepreload';
    link.href = `/routes/${routeName}.js`;
    document.head.appendChild(link);
  }
}

// 3. 长任务优化
class LongTaskOptimizer {
  static breakLongTask(task, chunkSize = 5) {
    return new Promise((resolve) => {
      const chunks = this.chunkArray(task, chunkSize);
      let currentChunk = 0;
      
      const processChunk = () => {
        if (currentChunk < chunks.length) {
          chunks[currentChunk].forEach(item => {
            // 处理每个数据项
            this.processItem(item);
          });
          currentChunk++;
          
          // 使用setTimeout让出主线程
          setTimeout(processChunk, 0);
        } else {
          resolve();
        }
      };
      
      processChunk();
    });
  }
  
  static chunkArray(array, size) {
    const chunks = [];
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size));
    }
    return chunks;
  }
  
  static processItem(item) {
    // 处理单个数据项的逻辑
    console.log('Processing item:', item);
  }
}

// 4. 第三方脚本优化
class ThirdPartyOptimizer {
  static deferThirdPartyScripts() {
    // 延迟加载非关键第三方脚本
    const thirdPartyScripts = document.querySelectorAll('script[data-third-party]');
    thirdPartyScripts.forEach(script => {
      script.defer = true;
      script.async = true;
    });
  }
  
  static loadThirdPartyOnInteraction() {
    // 在用户交互时加载第三方脚本
    const loadThirdParty = () => {
      const scripts = [
        'https://www.google-analytics.com/analytics.js',
        'https://connect.facebook.net/en_US/fbevents.js'
      ];
      
      scripts.forEach(src => {
        const script = document.createElement('script');
        script.src = src;
        script.async = true;
        document.head.appendChild(script);
      });
    };
    
    // 在用户首次交互时加载
    ['click', 'scroll', 'keydown'].forEach(event => {
      document.addEventListener(event, loadThirdParty, { once: true });
    });
  }
}

// 5. 内存优化
class MemoryOptimizer {
  static optimizeMemoryUsage() {
    // 定期清理不需要的数据
    setInterval(() => {
      this.cleanupUnusedData();
      this.forceGarbageCollection();
    }, 30000); // 每30秒清理一次
  }
  
  static cleanupUnusedData() {
    // 清理未使用的缓存
    if (window.caches) {
      caches.keys().then(names => {
        names.forEach(name => {
          if (name.includes('old-')) {
            caches.delete(name);
          }
        });
      });
    }
  }
  
  static forceGarbageCollection() {
    // 在支持的环境中强制垃圾回收
    if (window.gc) {
      window.gc();
    }
  }
}

// 6. TTI性能分析工具
class TTIAnalyzer {
  constructor() {
    this.metrics = {};
    this.init();
  }
  
  init() {
    this.analyzeLongTasks();
    this.analyzeResourceLoading();
    this.analyzeJavaScriptExecution();
  }
  
  analyzeLongTasks() {
    new PerformanceObserver((entryList) => {
      for (const entry of entryList.getEntries()) {
        console.warn(`长任务检测: ${entry.duration}ms at ${entry.startTime}`);
        
        // 分析长任务的原因
        this.analyzeLongTaskCause(entry);
      }
    }).observe({entryTypes: ['longtask']});
  }
  
  analyzeLongTaskCause(entry) {
    // 分析长任务发生时的资源加载情况
    const resources = performance.getEntriesByType('resource');
    const concurrentResources = resources.filter(resource => {
      return resource.startTime <= entry.startTime && 
             resource.responseEnd >= entry.startTime;
    });
    
    console.log('长任务期间的并发资源:', concurrentResources);
  }
  
  analyzeResourceLoading() {
    const resources = performance.getEntriesByType('resource');
    const jsResources = resources.filter(resource => 
      resource.name.endsWith('.js')
    );
    
    const totalJSTime = jsResources.reduce((total, resource) => {
      return total + (resource.responseEnd - resource.startTime);
    }, 0);
    
    console.log('JavaScript资源总加载时间:', totalJSTime);
  }
  
  analyzeJavaScriptExecution() {
    // 分析JavaScript执行时间
    const scripts = performance.getEntriesByType('resource')
      .filter(entry => entry.name.endsWith('.js'));
    
    scripts.forEach(script => {
      console.log(`脚本 ${script.name} 加载时间: ${script.responseEnd - script.startTime}ms`);
    });
  }
  
  getOptimizationSuggestions() {
    const suggestions = [];
    
    if (this.metrics.tti > 3800) {
      suggestions.push('TTI超过3.8秒，建议优化JavaScript执行和资源加载');
    }
    
    if (this.longTasks.length > 5) {
      suggestions.push('检测到多个长任务，建议进行代码分割和任务分解');
    }
    
    return suggestions;
  }
}
```

## 内存管理与泄漏检测

### 常见内存泄漏场景

#### 1. 全局变量
```javascript
// ❌ 错误示例
function createLeak() {
  accidentalGlobal = new Array(1000000).fill('data');
}

// ✅ 正确示例
function createSafe() {
  const localData = new Array(1000000).fill('data');
  // 函数执行完毕后，localData会被垃圾回收
}
```

#### 2. 未清理的事件监听器
```javascript
// ❌ 错误示例
function setupComponent() {
  const element = document.getElementById('button');
  element.addEventListener('click', handleClick);
  // 组件销毁时未移除监听器
}

// ✅ 正确示例
class Component {
  constructor() {
    this.handleClick = this.handleClick.bind(this);
    this.element = document.getElementById('button');
    this.element.addEventListener('click', this.handleClick);
  }
  
  destroy() {
    this.element.removeEventListener('click', this.handleClick);
  }
  
  handleClick() {
    // 处理点击事件
  }
}
```

#### 3. 定时器未清理
```javascript
// ❌ 错误示例
function startTimer() {
  setInterval(() => {
    console.log('Timer running...');
  }, 1000);
  // 定时器永远不会被清理
}

// ✅ 正确示例
class TimerManager {
  constructor() {
    this.timers = [];
  }
  
  addTimer(callback, interval) {
    const timerId = setInterval(callback, interval);
    this.timers.push(timerId);
    return timerId;
  }
  
  clearAllTimers() {
    this.timers.forEach(clearInterval);
    this.timers = [];
  }
}
```

#### 4. 闭包引起的内存泄漏
```javascript
// ❌ 错误示例
function createClosure() {
  const largeData = new Array(1000000).fill('data');
  
  return function() {
    // 即使不使用largeData，闭包也会保持对它的引用
    console.log('Function called');
  };
}

// ✅ 正确示例
function createOptimizedClosure() {
  const largeData = new Array(1000000).fill('data');
  
  // 处理完数据后清空引用
  const processedData = largeData.length;
  largeData.length = 0; // 清空数组
  
  return function() {
    console.log('Processed data length:', processedData);
  };
}
```

### 内存监控工具

#### Performance API
```javascript
class MemoryMonitor {
  static getMemoryInfo() {
    if ('memory' in performance) {
      return {
        usedJSHeapSize: performance.memory.usedJSHeapSize,
        totalJSHeapSize: performance.memory.totalJSHeapSize,
        jsHeapSizeLimit: performance.memory.jsHeapSizeLimit
      };
    }
    return null;
  }
  
  static startMonitoring(interval = 5000) {
    return setInterval(() => {
      const memInfo = MemoryMonitor.getMemoryInfo();
      if (memInfo) {
        console.log('内存使用情况:', {
          used: (memInfo.usedJSHeapSize / 1024 / 1024).toFixed(2) + ' MB',
          total: (memInfo.totalJSHeapSize / 1024 / 1024).toFixed(2) + ' MB',
          limit: (memInfo.jsHeapSizeLimit / 1024 / 1024).toFixed(2) + ' MB'
        });
      }
    }, interval);
  }
}
```

#### WeakMap 和 WeakSet 的使用
```javascript
// 使用WeakMap避免内存泄漏
class ComponentManager {
  constructor() {
    this.componentData = new WeakMap();
  }
  
  setData(component, data) {
    this.componentData.set(component, data);
  }
  
  getData(component) {
    return this.componentData.get(component);
  }
  
  // 当component被垃圾回收时，对应的数据也会自动被清理
}
```

## 渲染性能优化

### 重排与重绘优化

#### 批量DOM操作
```javascript
// ❌ 错误示例：多次触发重排
function updateStylesBad(elements) {
  elements.forEach(el => {
    el.style.width = '100px';
    el.style.height = '100px';
    el.style.background = 'red';
  });
}

// ✅ 正确示例：批量操作
function updateStylesGood(elements) {
  const fragment = document.createDocumentFragment();
  elements.forEach(el => {
    el.style.cssText = 'width: 100px; height: 100px; background: red;';
    fragment.appendChild(el);
  });
  document.body.appendChild(fragment);
}
```

#### 使用transform和opacity
```javascript
// ❌ 触发重排的动画
function animateBad(element) {
  element.style.left = '100px';
  element.style.top = '100px';
}

// ✅ 只触发合成的动画
function animateGood(element) {
  element.style.transform = 'translate(100px, 100px)';
}
```

### 虚拟滚动实现
```javascript
class VirtualList {
  constructor(container, itemHeight, items) {
    this.container = container;
    this.itemHeight = itemHeight;
    this.items = items;
    this.visibleCount = Math.ceil(container.clientHeight / itemHeight);
    this.startIndex = 0;
    
    this.init();
  }
  
  init() {
    this.container.style.height = this.items.length * this.itemHeight + 'px';
    this.container.addEventListener('scroll', this.onScroll.bind(this));
    this.render();
  }
  
  onScroll() {
    const scrollTop = this.container.scrollTop;
    this.startIndex = Math.floor(scrollTop / this.itemHeight);
    this.render();
  }
  
  render() {
    const endIndex = Math.min(this.startIndex + this.visibleCount, this.items.length);
    const visibleItems = this.items.slice(this.startIndex, endIndex);
    
    this.container.innerHTML = '';
    visibleItems.forEach((item, index) => {
      const element = document.createElement('div');
      element.style.height = this.itemHeight + 'px';
      element.style.transform = `translateY(${(this.startIndex + index) * this.itemHeight}px)`;
      element.textContent = item;
      this.container.appendChild(element);
    });
  }
}
```

## 网络性能优化

### 资源预加载策略
```html
<!-- DNS预解析 -->
<link rel="dns-prefetch" href="//example.com">

<!-- 预连接 -->
<link rel="preconnect" href="https://fonts.googleapis.com">

<!-- 资源预加载 -->
<link rel="preload" href="/critical.css" as="style">
<link rel="preload" href="/hero-image.jpg" as="image">

<!-- 预取资源 -->
<link rel="prefetch" href="/next-page.js">
```

### 图片优化
```javascript
class ImageOptimizer {
  static createResponsiveImage(src, alt, sizes = []) {
    const img = document.createElement('img');
    img.src = src;
    img.alt = alt;
    
    if (sizes.length > 0) {
      img.srcset = sizes.map(size => `${size.src} ${size.w}w`).join(', ');
      img.sizes = sizes.map(size => size.media).join(', ');
    }
    
    // 懒加载
    img.loading = 'lazy';
    
    return img;
  }
  
  static lazyLoad(selector) {
    if ('IntersectionObserver' in window) {
      const imageObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target;
            img.src = img.dataset.src;
            img.classList.remove('lazy');
            imageObserver.unobserve(img);
          }
        });
      });
      
      document.querySelectorAll(selector).forEach(img => {
        imageObserver.observe(img);
      });
    }
  }
}
```

### Service Worker缓存策略
```javascript
// sw.js
const CACHE_NAME = 'app-cache-v1';
const urlsToCache = [
  '/',
  '/styles/main.css',
  '/scripts/main.js'
];

// 安装Service Worker
self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(urlsToCache))
  );
});

// 拦截网络请求
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        // 缓存命中则返回缓存，否则发起网络请求
        if (response) {
          return response;
        }
        return fetch(event.request);
      }
    )
  );
});
```

## 性能监控工具

### 自定义性能监控
```javascript
class PerformanceMonitor {
  constructor() {
    this.metrics = {};
    this.observers = [];
    this.init();
  }
  
  init() {
    this.setupObservers();
    this.collectNavigationTiming();
  }
  
  setupObservers() {
    // 监控LCP
    this.observeMetric('largest-contentful-paint', 'lcp');
    
    // 监控FID
    this.observeMetric('first-input', 'fid');
    
    // 监控CLS
    this.observeLayoutShift();
    
    // 监控长任务
    this.observeLongTasks();
  }
  
  observeMetric(entryType, metricName) {
    const observer = new PerformanceObserver((entryList) => {
      for (const entry of entryList.getEntries()) {
        this.metrics[metricName] = entry.startTime;
      }
    });
    observer.observe({entryTypes: [entryType]});
    this.observers.push(observer);
  }
  
  observeLayoutShift() {
    let clsValue = 0;
    const observer = new PerformanceObserver((entryList) => {
      for (const entry of entryList.getEntries()) {
        if (!entry.hadRecentInput) {
          clsValue += entry.value;
        }
      }
      this.metrics.cls = clsValue;
    });
    observer.observe({entryTypes: ['layout-shift']});
    this.observers.push(observer);
  }
  
  observeLongTasks() {
    const observer = new PerformanceObserver((entryList) => {
      for (const entry of entryList.getEntries()) {
        console.warn('Long task detected:', entry.duration + 'ms');
      }
    });
    observer.observe({entryTypes: ['longtask']});
    this.observers.push(observer);
  }
  
  collectNavigationTiming() {
    window.addEventListener('load', () => {
      const timing = performance.getEntriesByType('navigation')[0];
      this.metrics.ttfb = timing.responseStart - timing.requestStart;
      this.metrics.domLoad = timing.domContentLoadedEventEnd - timing.navigationStart;
      this.metrics.windowLoad = timing.loadEventEnd - timing.navigationStart;
    });
  }
  
  getMetrics() {
    return { ...this.metrics };
  }
  
  disconnect() {
    this.observers.forEach(observer => observer.disconnect());
  }
}
```

### 错误监控
```javascript
class ErrorMonitor {
  constructor() {
    this.errors = [];
    this.init();
  }
  
  init() {
    // 监控JavaScript错误
    window.addEventListener('error', this.handleError.bind(this));
    
    // 监控Promise错误
    window.addEventListener('unhandledrejection', this.handlePromiseError.bind(this));
    
    // 监控资源加载错误
    window.addEventListener('error', this.handleResourceError.bind(this), true);
  }
  
  handleError(event) {
    const error = {
      type: 'javascript',
      message: event.message,
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno,
      stack: event.error?.stack,
      timestamp: Date.now()
    };
    this.logError(error);
  }
  
  handlePromiseError(event) {
    const error = {
      type: 'promise',
      message: event.reason.message || event.reason,
      stack: event.reason.stack,
      timestamp: Date.now()
    };
    this.logError(error);
  }
  
  handleResourceError(event) {
    if (event.target !== window) {
      const error = {
        type: 'resource',
        element: event.target.tagName.toLowerCase(),
        source: event.target.src || event.target.href,
        timestamp: Date.now()
      };
      this.logError(error);
    }
  }
  
  logError(error) {
    this.errors.push(error);
    console.error('Error logged:', error);
    // 这里可以发送到监控服务
  }
  
  getErrors() {
    return [...this.errors];
  }
}
```

## 实战案例

### 大型列表性能优化
```javascript
class OptimizedList {
  constructor(container, data) {
    this.container = container;
    this.data = data;
    this.itemHeight = 50;
    this.visibleItems = Math.ceil(container.clientHeight / this.itemHeight) + 2;
    this.scrollTop = 0;
    
    this.init();
  }
  
  init() {
    this.createVirtualContainer();
    this.bindEvents();
    this.render();
  }
  
  createVirtualContainer() {
    this.viewport = document.createElement('div');
    this.viewport.className = 'virtual-viewport';
    this.viewport.style.cssText = `
      height: 100%;
      overflow-y: auto;
      position: relative;
    `;
    
    this.content = document.createElement('div');
    this.content.className = 'virtual-content';
    this.content.style.height = this.data.length * this.itemHeight + 'px';
    
    this.itemContainer = document.createElement('div');
    this.itemContainer.className = 'virtual-items';
    this.itemContainer.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
    `;
    
    this.content.appendChild(this.itemContainer);
    this.viewport.appendChild(this.content);
    this.container.appendChild(this.viewport);
  }
  
  bindEvents() {
    this.viewport.addEventListener('scroll', this.throttle(this.onScroll.bind(this), 16));
  }
  
  onScroll() {
    this.scrollTop = this.viewport.scrollTop;
    this.render();
  }
  
  render() {
    const startIndex = Math.floor(this.scrollTop / this.itemHeight);
    const endIndex = Math.min(startIndex + this.visibleItems, this.data.length);
    
    // 清空现有items
    this.itemContainer.innerHTML = '';
    
    // 渲染可见items
    for (let i = startIndex; i < endIndex; i++) {
      const item = this.createItem(this.data[i], i);
      this.itemContainer.appendChild(item);
    }
    
    // 调整容器位置
    this.itemContainer.style.transform = `translateY(${startIndex * this.itemHeight}px)`;
  }
  
  createItem(data, index) {
    const item = document.createElement('div');
    item.className = 'list-item';
    item.style.cssText = `
      height: ${this.itemHeight}px;
      padding: 10px;
      border-bottom: 1px solid #eee;
      display: flex;
      align-items: center;
    `;
    item.textContent = `Item ${index}: ${data.title}`;
    return item;
  }
  
  throttle(func, limit) {
    let inThrottle;
    return function() {
      const args = arguments;
      const context = this;
      if (!inThrottle) {
        func.apply(context, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }
}
```

## 总结

前端性能优化是一个系统性工程，需要从多个维度进行考虑：

1. **测量为先**：使用合适的工具和指标来量化性能
2. **渐进优化**：从影响最大的问题开始，逐步优化
3. **持续监控**：建立性能监控体系，及时发现和解决问题
4. **用户体验**：始终以用户体验为中心，平衡性能和功能

通过本文介绍的方法和工具，你可以系统性地提升Web应用的性能，为用户提供更好的体验。

## 参考资料

- [Web Vitals](https://web.dev/vitals/)
- [Performance API](https://developer.mozilla.org/en-US/docs/Web/API/Performance)
- [Chrome DevTools Performance](https://developers.google.com/web/tools/chrome-devtools/performance)
- [Lighthouse](https://developers.google.com/web/tools/lighthouse)
