
### 应用加载流程

```typescript
// 1. 动态配置加载
SPAStore.fetch('Business').then((apps) => {
  // apps 来自 /configs/portal/apps.json
  initSpaService(apps);
});

// 2. SystemJS 动态导入
const loadingFnc = () => {
  const entrance = `${app.entrance}?tsPortal=${Date.now()}`; // 防缓存
  return SystemJS.import(entrance).then((entranceModule) => {
    return {
      bootstrap: (data) => entranceModule.bootstrap(data),
      mount: (data) => entranceModule.mount(data),
      unmount: (data) => entranceModule.unmount(data),
    };
  });
};

// 3. 应用注册和激活
singleSPA.registerApplication(app.name, loadingFnc, hashPrefix(app.rootHash), PortalService);
```

### 生命周期管理

- **Bootstrap** - 应用首次加载，初始化配置和依赖
- **Mount** - 路由激活时挂载应用到指定 DOM 节点
- **Unmount** - 路由切换时清理资源和 DOM

### 应用配置示例

```json
{
  "name": "business-app",
  "entrance": "http://localhost:3001/entry.js",
  "rootHash": "/business",
  "props": {
    "container": "#subapp-container"
  }
}
```

### 技术细节

#### 1. 缓存控制

- 使用时间戳参数防止应用缓存
- 开发环境动态更新，生产环境长期缓存

#### 2. 错误处理

```typescript
// 错误边界处理应用加载失败
SystemJS.import(entrance).catch((error) => {
  console.error('应用加载失败', error);
  // 降级处理或重试机制
});
```

#### 3. 状态监控

```typescript
// 应用状态实时监控
export function checkAppStatuses() {
  const appNames = singleSPA.getAppNames();
  appNames.forEach((appName) => {
    const status = singleSPA.getAppStatus(appName);
    if (status === 'SKIP_BECAUSE_BROKEN') {
      console.error(`应用 ${appName} 处于损坏状态`);
    }
  });
}
```

### 加载优化策略

1. **预加载** - 关键应用资源预加载
2. **懒加载** - 按需加载非关键应用
3. **并行加载** - 多个应用并行初始化
4. **错误恢复** - 应用失败时的恢复机制

[← 上一个问题：应用通信机制](03-主从应用之间是如何通信的.md) | [下一个问题：技术挑战和解决方案 →](05-项目中遇到了哪些技术挑战和坑点.md)
