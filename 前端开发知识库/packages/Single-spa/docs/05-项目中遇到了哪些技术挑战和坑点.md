
### 1. 样式隔离问题

```typescript
// 问题：子应用样式互相污染
// 解决方案：JSS + CSS Module + 命名空间
const generateClassName = generateJssClassName('Portal');

<JssProvider generateId={generateClassName}>
  <ThemeProvider theme={ThemeStore.theme}>{/* 应用内容 */}</ThemeProvider>
</JssProvider>;
```

**解决方案详解：**

#### A. JSS 顶层隔离机制

- **全局容器隔离**：通过 `JssProvider` 为整个应用提供唯一的类名生成器
- **动态类名生成**：`generateJssClassName('Portal')` 确保不同应用生成的类名不冲突
- **主题系统集成**：与 `ThemeProvider` 结合，支持动态主题切换

#### B. 组件级 createUseStyles 使用

**主要使用模式：**

```typescript
// packages/business/src/views/home/components/welcome-header/index.tsx
import { createUseStyles } from 'react-jss';
import * as styles from './index.jss';

const useStyles = createUseStyles(styles, { name: 'welcome-header' });

const WelcomeHeader: React.FC = () => {
  const classes = useStyles(); // 获取带命名空间的类名
  return <div className={classes.container}>...</div>;
};
```

**JSS 样式文件结构：**

```typescript
// packages/business/src/views/home/components/welcome-header/index.jss.ts
import { JssStyle } from 'jss';

export const container: JssStyle = {
  width: '100%',
  textAlign: 'start',
  paddingTop: 24,
  marginBottom: 24,
};

export const greeting: JssStyle = {
  fontSize: 24,
  fontWeight: 600,
  color: grey[800],
};
```

**优势分析：**

- **组件级隔离**：每个组件都有独立的样式作用域
- **TypeScript 支持**：完整的类型提示和编译时检查
- **命名规范**：通过 `name` 参数提供语义化的类名前缀
- **开发体验**：热重载友好，样式变更即时生效

#### C. 混合技术栈兼容性处理

**Class 组件兼容方案：**

```typescript
// packages/common/components/jss-hooks-in-classes/index.tsx
export function createStyles<T extends string>(classes: { [key in T]: Partial<JssStyle> }) {
  return createUseStyles<T>(classes);
}

export function Styles<T extends string | number | symbol>(props: {
  styles: () => Classes<T>;
  children: (classes: Classes<T>) => React.ReactElement;
}) {
  const classes = props.styles();
  return props.children(classes);
}

// 使用示例
const classes = createStyles({
  title: { color: 'red' },
});

export const Test: FC = () => {
  return <Styles styles={classes}>{(classes) => <div className={classes.title}>title</div>}</Styles>;
};
```

**解决的问题：**

- **Hooks 限制**：解决了 class 组件无法直接使用 `createUseStyles` 的问题
- **兼容性**：支持 React 16.13.1 + Angular 1.5.8 混合技术栈
- **统一性**：保持了样式隔离的一致性

#### D. CSS Module 编译时隔离

**Webpack 配置：**

```javascript
{
  test: /\.scss$/,
  use: [
    {
      loader: 'typings-for-css-modules-loader',
      options: {
        modules: true,
        namedExport: true,
        camelCase: true,
        localIdentName: '[local]__[hash:base64:5]',
        banner: '// 该文件由 typings-for-css-modules-loader 自动生成',
      },
    },
  ],
}
```

**实际应用场景统计：**

- **createUseStyles 使用频率**：在子应用中占比 90% 以上
- **覆盖组件类型**：页面级组件、业务组件、通用组件
- **样式文件数量**：17+ 个 JSS 样式文件，涵盖主要业务场景

**技术选型对比：**

| 方案                      | 运行时开销 | 开发体验 | 类型安全 | 兼容性        | 隔离效果  |
| ------------------------- | ---------- | -------- | -------- | ------------- | --------- |
| **JSS + createUseStyles** | ✅ 低      | ✅ 优秀  | ✅ 完整  | ✅ 广泛       | ✅ 强隔离 |
| **CSS Module**            | ✅ 无      | ⚠️ 中等  | ✅ 支持  | ✅ 广泛       | ✅ 强隔离 |
| **Styled Components**     | ❌ 高      | ✅ 优秀  | ✅ 完整  | ⚠️ React 限制 | ✅ 强隔离 |
| **CSS-in-JS (Emotion)**   | ⚠️ 中等    | ✅ 优秀  | ✅ 完整  | ⚠️ 现代浏览器 | ✅ 强隔离 |

**最终效果：**

- 完全避免了子应用间的样式冲突
- 支持动态主题切换，所有应用同步更新
- 开发时有完整的 TypeScript 支持和智能提示
- 构建产物中类名被正确混淆，避免样式污染

### 2. 路由冲突问题

```typescript
// 问题：子应用路由与主应用冲突
// 解决方案：Hash 路由 + 路径前缀隔离
export function hashPrefix(prefix: string) {
  return (location: Location) => {
    return location.hash.startsWith(`#${prefix}`);
  };
}
```

**技术要点：**

- 每个子应用使用独立的路由前缀
- 主应用负责路由分发和管理
- 支持深层路由和浏览器前进后退

### 3. 状态管理复杂性

```typescript
// 问题：跨应用状态同步困难
// 解决方案：分层状态管理 + 事件机制
class SPAStore {
  @observable public isLoading = false;
  @observable public subModuleError = false;

  @action public update(data: { isLoading?: boolean }) {
    Object.assign(this, data);
  }
}
```

**设计原则：**

- 主应用管理全局状态
- 子应用管理局部状态
- 通过事件机制同步关键状态

### 4. 应用加载超时处理

```typescript
// 问题：子应用加载超时导致页面白屏
// 解决方案：超时重试 + 降级处理
export function getSpaRoot(): Promise<HTMLDivElement> {
  return new Promise((resolve, reject) => {
    runTask(1000); // 设置超时时间

    function runTask(times: number) {
      if (times < 0) {
        console.error('获取SPA根节点超时');
        return reject();
      }
      // 重试逻辑
    }
  });
}
```

**优化策略：**

- 设置合理的超时时间
- 实现指数退避重试机制
- 提供友好的降级页面

### 5. 构建和部署复杂度

```json
// 问题：多应用构建和发布流程复杂
// 解决方案：Lerna 统一管理 + 脚本自动化
{
  "scripts": {
    "build": "npm run build:business && npm run build:implement",
    "start:business": "cd packages/business && npm run start",
    "start:implement": "cd packages/implement && npm run start"
  }
}
```

**自动化方案：**

- Lerna 管理 Monorepo 依赖
- 统一的构建和发布脚本
- CI/CD 流水线自动化部署

### 6. 内存泄漏问题

**常见问题：**

- 事件监听器未正确清理
- 定时器在应用卸载时未清除
- DOM 引用未释放

**解决方案：**

```typescript
export function unmount(config) {
  // 清理事件监听器
  window.removeEventListener('resize', handleResize);

  // 清理定时器
  if (timer) {
    clearInterval(timer);
  }

  // 清理 DOM 引用
  ReactDOM.unmountComponentAtNode(root);

  return Promise.resolve();
}
```

### 7. 版本兼容性问题

**挑战：**

- 不同应用使用不同版本的依赖
- 共享依赖版本冲突
- API 接口版本不一致

**解决策略：**

- 制定依赖版本管理规范
- 使用 peerDependencies 管理共享依赖
- API 版本化和向后兼容设计

[← 上一个问题：应用加载和管理](04-微前端应用是如何加载和管理.md) | [下一个问题：性能优化策略 →](06-如何保证微前端应用的性能.md)
