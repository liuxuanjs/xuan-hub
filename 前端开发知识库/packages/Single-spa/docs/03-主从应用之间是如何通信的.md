
### 我们实现了多种通信方式

#### 1. 全局服务共享（主要方式）

```typescript
// 主应用暴露全局服务
(window as any).KyPortalService = PortalService;

// 子应用通过全局对象访问
const { ThemeService, LanguageService } = window.KyPortalService;
```

#### 2. EventBus 事件通信

```typescript
// 语言切换事件通信
export const LanguageEventBus = {
  emit: (language: string) => {
    window.dispatchEvent(new CustomEvent('language-change', { detail: language }));
  },
  on: (callback: Function) => {
    window.addEventListener('language-change', callback);
  },
};
```

#### 3. 状态管理层通信

```typescript
// MobX Store 跨应用共享
class SystemStore {
  @observable config: ISystemConfig = {};

  // 系统配置变更会自动通知所有应用
  @action updateConfig(config: ISystemConfig) {
    this.config = config;
  }
}
```

#### 4. URL 参数通信

```typescript
// 通过路由参数传递数据
const hashPrefix = (prefix: string) => {
  return (location: Location) => {
    return location.hash.startsWith(`#${prefix}`);
  };
};
```

### 通信场景举例

- **主题切换** - 主应用更新主题，所有子应用自动响应
- **用户登录** - 认证信息通过全局服务共享
- **语言切换** - EventBus 广播语言变更事件
- **面包屑导航** - 子应用更新面包屑到主应用

### 通信方式选择原则

| 通信方式 | 适用场景           | 优点             | 缺点       |
| -------- | ------------------ | ---------------- | ---------- |
| 全局服务 | 服务调用、状态共享 | 简单直接、性能好 | 全局污染   |
| EventBus | 事件通知、解耦通信 | 松耦合、灵活     | 调试困难   |
| 状态管理 | 复杂状态同步       | 响应式、可追踪   | 复杂度高   |
| URL 参数 | 页面间传参         | 可刷新保持       | 数据量限制 |

## 深度解析：为什么选择 Window 挂载服务？

### 技术背景分析

在微前端架构中，我们面临几个核心挑战：

1. **跨应用通信难题** - 各子应用独立打包，无法通过 ES6 模块导入共享服务
2. **技术栈异构** - React、Angular、Vue 需要统一的通信方式
3. **动态加载限制** - 运行时加载的应用无法在编译时确定依赖

### 方案对比与选择

#### 1. Window 挂载 vs 参数传递

```typescript
// ❌ 纯参数传递的局限性
export function mount(config: IPortalService) {
  // 问题1：只能在生命周期函数中访问
  // 问题2：深层组件需要层层传递
  // 问题3：子应用可能需要在 bootstrap 之前访问服务
}

// ✅ Window 挂载的优势
(window as any).KyPortalService = PortalService;
// 优势1：任何时机都能访问
// 优势2：所有组件直接获取
// 优势3：跨框架统一访问方式
```

#### 2. Window 挂载 vs EventBus

```typescript
// EventBus 适合事件通知
export const LanguageEventBus = {
  emit: (language: string) => {
    window.dispatchEvent(new CustomEvent('language-change', { detail: language }));
  },
};

// ❌ 无法通过 EventBus 调用复杂服务
// ✅ Window 挂载支持直接服务调用
window.KyPortalService.ThemeService.updateTheme('dark');
window.KyPortalService.RequestService.post('/api/data');
```

### 实际业务场景驱动

#### Widget 系统的复杂需求

```typescript
// Widget 需要注入大量服务
private getInjectObj = () => {
  return {
    LoginService,
    ThemeService,
    RequestService,
    AccountService,
    PermissionService,
    BreadcrumbService,
    LanguageService,
    VerificationService,
    // ... 15+ 个服务
  };
};
```

如果不通过 window 全局暴露，每个 Widget 都需要重新传递这些服务，维护成本极高。

#### 开发体验优化

```typescript
// 子应用开发时的灵活性
export function mount(config: IPortalService) {
  // 既可以使用全局服务，也可以使用传入的服务
  const themeService = window.KyPortalService.ThemeService || config.ThemeService;

  ReactDOM.render(<App themeService={themeService} />, container);
}
```

### 潜在问题与解决方案

#### 1. 全局污染控制

```typescript
// ✅ 使用命名空间避免冲突
(window as any).KyPortalService = PortalService;

// ❌ 直接挂载容易冲突
// window.ThemeService = ThemeService;
```

#### 2. TypeScript 类型安全

```typescript
// 提供完整的类型定义
interface Window {
  KyPortalService: IPortalConfig;
}
```

### 架构演进思考

这个选择体现了**工程实用主义**的设计哲学：

- **理论完美性** - 完全解耦，无全局状态
- **实际可操作性** - 开发便利，维护简单
- **团队协作效率** - 统一标准，降低门槛

**结论：** 在微前端的复杂场景下，Window 挂载是平衡各种因素后的最优解。

[← 上一个问题：架构设计详解](02-你们的微前端架构是如何设计的.md) | [下一个问题：应用加载和管理 →](04-微前端应用是如何加载和管理.md)
