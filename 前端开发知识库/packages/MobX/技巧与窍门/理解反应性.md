
Mobx 通常会像你所期待的那样对确定的一些事物做出响应，这意味着在 90% 的用例中 Mobx 都应该能正常工作。 但是在不确定的某个时间，你可能会遇到一些情况，Mobx 并没有在这些情况下做出你所预想的响应。 面对这些情况，理解 Mobx 如何确定要对哪些事物做出响应是十分重要的。

> Mobx 会对跟踪函数执行时读取的任何 _存在的_ **可观察的** _属性_ 做出响应。

- "读取" 是对对象属性进行取消引用，可以通过 "点"（例如 `user.name`）或使用括号表示法（例如 `user['name']`，`todos[3]`）或解构（例如 `const {name} = user`）来完成。
- "跟踪函数" 是指 `computed` 的表达式、 `observer` React 函数组件的呈现、基于 `observer` 的 React 类组件的 `render()` 方法，以及作为第一个参数传递给 `autorun` 、 `reaction` 和 `when` 的函数。
- "期间" 意味着只跟踪函数执行过程中读取的观察值。至于这些值是被跟踪函数直接使用还是间接使用，并不重要。但是从函数中 "生成 "的东西不会被跟踪（例如 `setTimeout` , `promise.then` , `await` 等）。

换句话说，MobX 不会对其作出反应：

- 从可观察对象中获取到，但是并没有在跟踪函数中使用的值

```js
import { makeAutoObservable } from "mobx";

class Counter {
	count = 0;
	constructor() {
		makeAutoObservable(this);
	}

	increment() {
		this.count += 1;
	}
}

const myCounter = new Counter();

// 读取 count，但不在 reaction 或 computed function 中，所以 MobX 不会对其做出反应
console.log(myCounter.count);
```

- 在异步调用的代码块中读取的可观察值

```js
import { makeAutoObservable } from "mobx";

class Counter {
	count = 0;
	constructor() {
		makeAutoObservable(this);
	}

	increment() {
		this.count += 1;
	}
}

const myCounter = new Counter();

// 在异步函数中读取 count，所以 MobX 不会对其做出反应
setTimeout(() => {
	console.log(myCounter.count);
}, 1000);
```

## MobX 跟踪属性的访问，而不是属性的值本身

举例说明上述规则，假设有以下可观察的实例：

```js
class Message {
	title
	author
	likes
	constructor(title, author, likes) {
		makeAutoObservable(this);
		this.title = title;
		this.author = author;
		this.likes = likes;
	}
	updateTitle(title) {
		this.title = title;
	}
}

let message = new Message("Foo", { name: "Michel" }, ["Joe", "Sara"]);
```

在内存中，它看起来如下。绿色框表示可观察属性。请注意，值本身是不可观察的！

![[observed-refs.png]]

简单来说，MobX 所做的就是记录下你在跟踪函数中所使用的属性的箭头指向（就像上图中的箭头那样）。在此之后，当这些箭头中的任何一个发生变化（比如该箭头从一个值指向另一个值）时，MobX 都会响应变化，并重新执行相应的跟踪函数。

## 例子

让我们用几个例子来说明这一点（基于上面定义的 `message` 变量）：

### 正确：在跟踪函数中使用某个对象的属性

```js
class Message {
	title
	author
	likes
	constructor(title, author, likes) {
		makeAutoObservable(this);
		this.title = title;
		this.author = author;
		this.likes = likes;
	}
	updateTitle(title) {
		this.title = title;
	}
}

let message = new Message("Foo", { name: "Michel" }, ["Joe", "Sara"]);

autorun(() => {
	console.log(message.title)
});
message.updateTitle("Bar");
```

这个例子将会产生符合期待的响应。 `.title` 属性被 autorun 函数使用，并且该属性在后面发生了改变，因此这个变化会被捕捉到。

您可以通过在跟踪函数中调用 `trace()` 来验证 MobX 将跟踪什么。上述函数的输出如下：

```js
import { trace } from "mobx";

const disposer = autorun(() => {
	console.log(message.title);
	trace();
});

// Outputs:
// [mobx.trace] 'Autorun@2' tracing enabled 

message.updateTitle("Hello");

// Outputs:
// [mobx.trace] 'Autorun@2' is invalidated due to a change in: 'Message@1.title'
Hello
```

也可以使用 `getDependencyTree` 获取内部依赖关系（或观察者）树：

```js
import { getDependencyTree } from "mobx";

// Prints the dependency tree of the reaction coupled to the disposer.
console.log(getDependencyTree(disposer));

// Outputs:
// { name: 'Autorun@2', dependencies: [ { name: 'Message@1.title' } ] }
```

### 错误：更改非可观察引用

```js
autorun(() => {
	console.log(message.title);
});

message = new Message("Bar", { name: "Martijn" }, ["Felicia", "Marcus"]);
```

这不会有任何反应。 `message` 被修改了，但 `message` 并不是一个可观察变量，只是一个引用可观察变量的变量，但变量（引用）本身并不是可观察的。


### 错误：在跟踪函数之外取消引用

```js
let title = message.title;
autorun(() => {
	console.log(title);
});
message.updateMessage("Bar");
```

这不会有任何反应。 `message.title` 是在 `autorun` 以外取消引用的，它只包含取消引用时 `message.title` 的值（字符串 `"Foo"` ）。 `title` 不是一个可观测变量，因此 `autorun` 不会有任何反应。

### 正确：在跟踪函数内部取消引用

```js
autorun(() => {
	console.log(message.author.name);
});

runInAction(() => {
	message.author.name = "Sara";
});
runInAction(() => {
	message.author = { name: "Joe" };
});
```

这会对这两种变化做出反应。 `author` 和 `author.name` 都是通过使用 "点" 来访问对象的属性，允许 MobX 跟踪这些引用。

请注意，我们必须在这里使用 `runInAction` 才能在 `action` 以外进行更改。

### 错误：在不跟踪的情况下存储可观察对象的本地引用

```js
const author = message.author;
autorun(() => {
	console.log(author.name);
});

runInAction(() => {
	message.author.name = "Sara";
});
runInAction(() => {
	message.author = { name: "Joe" };
});
```

由于 `message.author` 和 `author` 是同一个对象，并且 `.name` 属性在 `autorun` 中被取消引用，因此第一项更改将被捕获。但是，第二个变化没有被捕获，因为 `message.author` 关系没有被 `autorun` 跟踪。`autorun` 仍在使用 "旧的" `author` 属性。


### 常见陷阱：console.log

```js
autorun(() => {
	console.log(message);
});

// 不会触发重新运行.
message.updateTitle("Hello world");
```

在上面的示例中，更新后的消息标题不会被打印，因为它没有在 `autorun` 内部使用。Autorun 仅依赖于消息，这不是一个可观察对象，而是一个变量。换句话说，在MobX看来，`title` 在 `autorun` 中并未被使用。

如果您在Web浏览器调试工具中使用此功能，最终可能会找到 `title` 的更新值，但这是误导性的—— `autorun` 在首次调用时运行一次后才运行。这是因为 `console.log` 是一个异步函数，并且对象只有在稍后才被格式化。这意味着如果您跟踪调试工具栏中的 `title`，您可以找到更新后的值。但 `autorun` 不会跟踪任何更新。

实现这一功能的方法是确保始终向 `console.log` 传递 不可变数据 或 防御性副本。因此，以下解决方案都会对 `message.title` 中的更改做出反应：

```js
autorun(() => {
	console.log(message.title);
});
autorun(() => {
	console.log(mobx.toJS(message)); // toJS 会创建一个深度克隆，因此会读取信息
});
autorun(() => {
	console.log({ ...message }); // 创建一个浅克隆，同时在过程中使用 .title
});
autorun(() => {
	console.log(JSON.stringify(message));
});
```

### 正确：在跟踪函数中访问数组属性

```js
autorun(() => {
	console.log(message.likes.length);
});
message.likes.push("Jennifer");
```

这将产生预期的反应。 `.length` 对一个属性计数。请注意，这将对数组中的任何变化做出反应。数组不是按索引/属性跟踪的（就像可观察对象和地图一样），而是作为一个整体跟踪的。

### 错误：在跟踪函数中访问超出边界的索引

```js
autorun(() => {
	console.log(message.likes[0]);
});
message.likes.push("Jennifer");
```

这将与上述示例数据产生反应，因为数组索引算作属性访问。但前提是必须提供 `index < length` 。MobX 不会跟踪尚未存在的数组索引。因此，请务必使用 `.length` 检查来保护基于数组索引的访问。

### 正确：在跟踪函数中访问数组函数

```js
autorun(() => {
	console.log(message.likes.join(", "));
});
message.likes[2] = "Jennifer";
```

这将产生预期的反应。所有数组索引赋值都会被检测到，但只有当 `index <= length` 。

### 错误："使用 "一个可观察对象，但不访问其任何属性

```js
autorun(() => {
	message.likes;
});
message.likes.push("Jennifer");
```

这不会有任何反应。这是因为 `autorun` 并没有使用 `likes` 数组本身，而只是使用了数组的引用。与此相反， `message.likes = ["Jennifer"]` 将被接收；该语句并没有修改数组，而是修改了 `likes` 属性本身。