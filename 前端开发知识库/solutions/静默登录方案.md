## 概述

静默登录（Silent Login / Silent Authentication）本质上是在用户无感知的情况下自动获取有效的登录态，减少或避免用户每次打开页面都要输入账号密码。

---

## 1. 基于 Cookie（Session）保持会话

**原理**
- 用户首次登录后，后端通过 `Set-Cookie` 写入带有 `HttpOnly`、`Secure`、`SameSite` 的 session cookie。
- 之后每次请求浏览器自动带上 cookie，后端通过 session 验证身份。
- 如果 session 没过期，就实现了静默登录。

**优点**
- 简单直接，浏览器原生支持，无需额外存储 Token。
- 对安全性友好（`HttpOnly` 防止 XSS 读取 cookie）。
- 适合同域或子域场景。

**缺点**
- 跨域场景需要 CORS + `credentials: include` 支持。
- Session 过期后需要重新登录（可配合刷新接口延长）。
- 依赖服务端 session 存储（增加维护成本）。

**适用场景**
- 传统 Web 应用（如公司内部系统，单域环境）。

---

## 2. Access Token + Refresh Token 模式

**原理**
- 首次登录获取短期有效的 Access Token 和长期有效的 Refresh Token（后者只能在后端安全保存或以 `HttpOnly Cookie` 形式存储）。
- Access Token 过期后，前端调用刷新接口，用 Refresh Token 换新 Access Token，整个过程用户无感。

**优点**
- 无需频繁输入密码。
- Access Token 有效期短，降低泄露风险。
- 适合跨域、前后端分离、移动端等场景。

**缺点**
- 实现稍复杂，需要额外的刷新逻辑。
- Refresh Token 一旦被窃取，可能长时间被滥用（可加绑定 IP / UA 校验）。

**适用场景**
- 前后端分离系统、OAuth2.0 认证、跨平台应用（Web + App）。

---

## 3. 基于第三方 OAuth / SSO 的静默授权

**原理**
- 使用微信、支付宝、Google、公司 SSO 等 OAuth2.0/OpenID Connect 提供商。
- 登录态保存在第三方，前端通过隐式跳转或静默授权接口获取用户信息和 Token。

**优点**
- 用户不需要记本系统的密码，安全性由大厂保障。
- 适合多系统统一登录（单点登录 SSO）。
- 可以跨应用共享登录态。

**缺点**
- 实现依赖第三方平台，需配置回调域名、授权方式。
- 部分平台静默授权有限制（如微信必须先关注公众号/已授权过）。
- 可能会有一次短暂的重定向（不是真正的 0 跳转）。

**适用场景**
- 企业内部多系统统一登录（SSO）。
- 依赖第三方账户的业务（如微信小程序、Google Workspace）。

---

## 4. 基于 LocalStorage/IndexedDB 保存 Token

**原理**
- 登录后将 Token 存到 LocalStorage 或 IndexedDB。
- 刷新页面时直接读取本地 Token 发请求校验或刷新。

**优点**
- 实现简单，前端完全可控。
- 不依赖 Cookie，跨域方便。

**缺点**
- 安全风险高：XSS 可直接读取 Token。
- Token 长期存储可能被盗用（尤其是公共电脑）。
- 不适合存长期凭证（除非配合短期 Token + 刷新机制）。

**适用场景**
- 风险可控、对安全要求不高的应用。
- 纯前端 PWA 应用。

---

## 5. 隐藏 iframe + 后端验证

**原理**
1. **用户打开系统 B**
   - 系统 B 检测到当前没有有效 Token，需要去验证用户是否已经在系统 A 登录。
2. **B 页面里动态创建一个隐藏的 iframe**
   ```html
   <iframe src="https://system-a.com/silent-auth" style="display:none"></iframe>
   ```
   - `silent-auth` 是 A 提供的一个页面，它的作用是：
     - 自动携带 A 域下的 Cookie。
     - 调用 A 的后端验证当前 Cookie 是否有效。
3. **A 后端验证登录态**
   - 如果 Cookie 有效，生成一个新的 Token（给 B 用）。
4. **iframe 与父页面通信（postMessage）**
   ```js
   // iframe 内
   window.parent.postMessage({ token: 'abc123' }, 'https://system-b.com');

   // B 页面监听
   window.addEventListener('message', (event) => {
     if (event.origin === 'https://system-a.com') {
       localStorage.setItem('token', event.data.token);
     }
   });
   ```
5. **系统 B 拿到 Token 后直接当作已登录**

**优点**
- 无需让用户重新登录。
- 无需显式页面跳转。
- 多个子系统可以无缝共享登录态。

**缺点**
- 要求 A 和 B 同属一个信任体系。
- Safari/部分浏览器可能拦截第三方 Cookie。
- 需要配置 CORS / postMessage 安全校验。

**简单时序图**
```
用户浏览器
  ↓ 打开 B
系统B -------------- 创建隐藏iframe --> system-a.com/silent-auth
iframe -> 带Cookie访问A后端
A后端 -> 验证通过 -> 返回新Token到iframe
iframe -> postMessage(Token) -> 系统B
系统B -> 存储Token并自动登录
```

**适用场景**
- 多子系统（多域）共享登录态的场景。
