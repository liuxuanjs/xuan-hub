
## 什么是代码分割？

代码分割（Code Splitting）是将大的 JavaScript 文件拆分成多个小文件的技术，就像把一本厚书分成几个章节，用户可以按需阅读。

### 核心思想
- **传统方式**：所有代码打包成一个大文件，用户一次性下载
- **代码分割**：将代码分成多个小块（chunk），按需加载

### 为什么需要代码分割？

**性能优化**：
- 减少首屏加载时间
- 避免下载用不到的代码
- 提升用户体验

**缓存优化**：
- 第三方库单独分割，更新业务代码时无需重新下载
- 浏览器可以更好地利用缓存

**实际场景**：
```js
// 用户访问首页 → 只加载首页代码
// 用户点击"设置" → 才加载设置页面代码
// 用户使用图表功能 → 才加载图表库代码
```

## 两种代码分割方式

### 1. 静态代码分割

**概念**：在打包时根据配置规则自动分割代码

**常见场景**：
- 第三方库分离（React、Lodash 等）
- 公共模块提取
- 多页面应用的页面分离

**Webpack 简单配置**：
```js
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
        }
      }
    }
  }
};
```

**打包结果**：
```
dist/
├── main.bundle.js     # 业务代码
├── vendors.bundle.js  # 第三方库
└── common.bundle.js   # 公共代码
```

### 2. 动态代码分割

**概念**：使用 `import()` 语法在运行时按需加载模块

**常见场景**：
- 路由懒加载
- 功能模块懒加载
- 条件加载

**基本用法**：
```js
// 点击按钮时才加载图表库
document.getElementById('chart-btn').addEventListener('click', async () => {
  const { Chart } = await import('./chart.js');
  new Chart().render();
});

// React 路由懒加载
const HomePage = lazy(() => import('./pages/Home'));
const AboutPage = lazy(() => import('./pages/About'));
```

**执行流程**：
1. 首次只加载主要代码
2. 触发条件时，动态请求对应的 chunk 文件
3. 加载完成后执行模块代码

## 实现原理

### 核心机制

**1. 依赖分析**
打包工具会分析代码中的模块依赖关系：
```js
// 打包工具分析这些导入语句
import React from 'react';           // 静态导入
import('./components/Modal.js');     // 动态导入
```

**2. 代码分割**
- 静态导入：通常打包在一起
- 动态导入：分割成独立的 chunk

**3. 运行时加载**
当需要动态模块时：
```js
// 1. 执行 import() 语句
const module = await import('./chart.js');

// 2. 浏览器创建 <script> 标签加载 chunk
// 3. 加载完成后返回模块内容
```

## 主流工具对比

| 工具 | 静态分割 | 动态分割 | 特点 |
|------|---------|---------|------|
| **Webpack** | ✅ 内置插件 | ✅ 完整支持 | 配置灵活，生态丰富 |
| **Vite** | ✅ 基于 Rollup | ✅ 原生支持 | 开发快速，生产优化 |
| **Rollup** | ✅ 手动配置 | ✅ 支持 | 专注库打包，体积小 |

### 简单配置示例

**Vite（推荐新项目）**：
```js
// vite.config.js
export default {
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom'],
          utils: ['lodash', 'moment']
        }
      }
    }
  }
}
```

## 最佳实践

### 1. 合理的分割策略

**按功能分割**：
```js
// 路由级别分割
const Home = lazy(() => import('./pages/Home'));
const Profile = lazy(() => import('./pages/Profile'));

// 功能级别分割
const ChartComponent = lazy(() => import('./components/Chart'));
```

**按库分割**：
```js
// 大型库单独分割
const loadEcharts = () => import('echarts');
const loadMoment = () => import('moment');
```

### 2. 避免过度分割

**❌ 错误做法**：
```js
// 过度分割，增加网络请求
const A = lazy(() => import('./tiny-component-a'));
const B = lazy(() => import('./tiny-component-b'));
```

**✅ 正确做法**：
```js
// 合理组合相关功能
const AdminComponents = lazy(() => import('./admin/index'));
```

### 3. 预加载优化

```js
// 在用户可能需要时预加载
const preloadChart = () => import(/* webpackPreload: true */ './chart');

// 在空闲时预加载
requestIdleCallback(() => {
  import('./analytics');
});
```

## 性能优化建议

### 分割粒度
- **太细**：网络请求过多，延迟增加
- **太粗**：加载不必要的代码
- **合适**：按功能模块和用户行为分割

### 缓存策略
```js
// 利用文件名哈希实现长期缓存
output: {
  filename: '[name].[contenthash].js',
  chunkFilename: '[name].[contenthash].chunk.js'
}
```

### 加载优化
- 使用 HTTP/2 减少多文件请求开销
- 配置 CDN 加速 chunk 文件加载
- 合理使用预加载和懒加载

## 总结

代码分割是现代前端性能优化的重要手段，通过合理的分割策略可以：

- **提升首屏性能**：减少初始加载代码量
- **优化用户体验**：按需加载，响应更快
- **改善缓存效果**：独立模块更新不影响其他部分

选择合适的工具和策略，根据项目实际情况进行优化，是实现最佳效果的关键。

