## 概述
CSS动画的性能直接影响用户体验，掌握优化技巧可以创建流畅的60fps动画，避免页面卡顿和掉帧。

## 性能基础知识

### 浏览器渲染流程
1. **Layout（布局）** - 计算元素位置和大小
2. **Paint（绘制）** - 填充像素
3. **Composite（合成）** - 图层合并

### 动画性能分类
```css
/* 高性能：只触发Composite */
.good {
    transform: translateX(100px);   /* ✅ 只影响合成层 */
    opacity: 0.5;                   /* ✅ 只影响合成层 */
}

/* 中等性能：触发Paint */
.okay {
    background-color: red;          /* ⚠️ 触发重绘 */
    color: blue;                    /* ⚠️ 触发重绘 */
}

/* 低性能：触发Layout */
.bad {
    width: 200px;                   /* ❌ 触发重排 */
    height: 100px;                  /* ❌ 触发重排 */
    margin: 20px;                   /* ❌ 触发重排 */
}
```

## 优化原则

### 1. 使用GPU加速属性
```css
/* 推荐：transform和opacity */
.optimized-animation {
    transform: translateX(0);
    opacity: 1;
    transition: transform 0.3s ease, opacity 0.3s ease;
}

.optimized-animation:hover {
    transform: translateX(20px);
    opacity: 0.8;
}
```

### 2. 避免layout属性
```css
/* 避免：会触发重排的属性 */
.bad-animation {
    left: 0;                        /* ❌ 触发layout */
    top: 0;                         /* ❌ 触发layout */
    width: 100px;                   /* ❌ 触发layout */
    transition: all 0.3s ease;
}

/* 推荐：使用transform替代 */
.good-animation {
    transform: translate(0, 0) scale(1);  /* ✅ 只触发composite */
    transition: transform 0.3s ease;
}
```

## 具体优化技巧

### 1. 位置动画优化
```css
/* 错误：使用left/top */
.move-bad {
    position: relative;
    left: 0;
    transition: left 0.3s ease;
}
.move-bad:hover {
    left: 100px;                    /* ❌ 触发layout */
}

/* 正确：使用transform */
.move-good {
    transform: translateX(0);
    transition: transform 0.3s ease;
}
.move-good:hover {
    transform: translateX(100px);   /* ✅ 高性能 */
}
```

### 2. 尺寸动画优化
```css
/* 错误：直接改变尺寸 */
.scale-bad {
    width: 100px;
    height: 100px;
    transition: width 0.3s ease, height 0.3s ease;
}
.scale-bad:hover {
    width: 150px;                   /* ❌ 触发layout */
    height: 150px;
}

/* 正确：使用transform scale */
.scale-good {
    transform: scale(1);
    transition: transform 0.3s ease;
}
.scale-good:hover {
    transform: scale(1.5);          /* ✅ 高性能 */
}
```

### 3. 颜色渐变优化
```css
/* 一般：background-color渐变 */
.color-fade {
    background-color: blue;
    transition: background-color 0.3s ease;  /* ⚠️ 触发paint */
}

/* 更好：使用opacity配合伪元素 */
.color-fade-optimized {
    position: relative;
}
.color-fade-optimized::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: red;
    opacity: 0;
    transition: opacity 0.3s ease;   /* ✅ 只触发composite */
}
.color-fade-optimized:hover::before {
    opacity: 1;
}
```

## will-change属性

### 基本用法
```css
.animation-element {
    will-change: transform;          /* 提示浏览器优化transform */
}

.complex-animation {
    will-change: transform, opacity; /* 多个属性 */
}
```

### 动态控制
```css
.hover-animation {
    transition: transform 0.3s ease;
}

.hover-animation:hover {
    will-change: transform;          /* 动画开始时添加 */
    transform: scale(1.1);
}
```

```javascript
// JavaScript动态控制
element.addEventListener('mouseenter', () => {
    element.style.willChange = 'transform';
});

element.addEventListener('animationend', () => {
    element.style.willChange = 'auto';  // 动画结束后移除
});
```

## 硬件加速技巧

### 创建新的合成层
```css
.create-layer {
    transform: translateZ(0);        /* 强制创建合成层 */
    /* 或者 */
    will-change: transform;
    /* 或者 */
    transform: translate3d(0, 0, 0);
}
```

### 避免层爆炸
```css
/* 问题：过多元素创建合成层 */
.many-elements {
    transform: translateZ(0);        /* 如果有很多这样的元素会影响性能 */
}

/* 解决：只在需要时创建 */
.optimized-elements {
    /* 默认不创建合成层 */
}
.optimized-elements.animating {
    will-change: transform;          /* 动画时才创建 */
}
```

## 实际应用示例

### 1. 卡片悬停效果
```css
.card {
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    will-change: transform;          /* 预期会变化 */
}

.card:hover {
    transform: translateY(-8px) scale(1.02);  /* 组合变换 */
    box-shadow: 0 10px 25px rgba(0,0,0,0.15);
}
```

### 2. 菜单滑动效果
```css
.menu-slide {
    transform: translateX(-100%);
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    will-change: transform;
}

.menu-slide.open {
    transform: translateX(0);
}
```

### 3. 按钮加载动画
```css
.btn-loading {
    position: relative;
    color: transparent;              /* 隐藏文字 */
}

.btn-loading::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 20px;
    height: 20px;
    margin: -10px 0 0 -10px;
    border: 2px solid #fff;
    border-top-color: transparent;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }  /* 只使用transform */
}
```

## 性能监控

### 使用Chrome DevTools
```javascript
// 在控制台监控FPS
const observer = new PerformanceObserver((list) => {
    for (const entry of list.getEntries()) {
        console.log('Frame time:', entry.duration);
    }
});
observer.observe({entryTypes: ['measure']});
```

### CSS中的性能提示
```css
.performance-debug {
    /* 临时添加，帮助调试 */
    outline: 2px solid red;
    will-change: transform, opacity;
}

/* 生产环境移除 */
```

## 动画最佳实践

### 1. 选择合适的缓动函数
```css
.smooth-animation {
    /* 推荐：自然的缓动 */
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    
    /* 避免：线性动画（除非特意需要） */
    /* transition: transform 0.3s linear; */
}
```

### 2. 控制动画时长
```css
.quick-feedback {
    transition: transform 0.15s ease;   /* 快速反馈 */
}

.smooth-transition {
    transition: transform 0.3s ease;    /* 平滑过渡 */
}

.dramatic-effect {
    transition: transform 0.6s ease;    /* 戏剧效果 */
}

/* 避免过长的动画 */
.too-slow {
    transition: transform 2s ease;      /* ❌ 用户会感到卡顿 */
}
```

### 3. 批量DOM操作
```javascript
// 错误：多次触发重排
element1.style.left = '100px';
element2.style.top = '50px';
element3.style.width = '200px';

// 正确：使用requestAnimationFrame批量更新
requestAnimationFrame(() => {
    element1.style.transform = 'translateX(100px)';
    element2.style.transform = 'translateY(50px)';
    element3.style.transform = 'scaleX(2)';
});
```

## 浏览器兼容性

### transform和opacity
- Chrome/Safari/Firefox：完全支持
- IE9+：支持2D变换
- IE10+：支持3D变换

### will-change
- Chrome 36+
- Firefox 36+
- Safari 9.1+

## 总结

CSS动画性能优化要点：

1. **优先使用transform和opacity**：只触发合成层
2. **避免layout属性**：width、height、margin等
3. **合理使用will-change**：提示浏览器优化
4. **控制合成层数量**：避免层爆炸
5. **选择合适的动画时长**：平衡流畅度和用户体验
6. **使用硬件加速**：但要适度

遵循这些原则可以创建流畅的60fps动画，提供优秀的用户体验。